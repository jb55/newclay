import newclay.common.*;
import newclay.lexer.(SourceTokens);
import newclay.ast as ast;
import newclay.ir as ir;
import newclay.diagnostics.*;
import newclay.platforms.*;
import newclay.hooks.*;

import algorithms.(sort);

import maybe.*;
import deques.*;
import numbers.floats.*;
import printer.formatter.*;



//
// Program
//

alias ModuleName = ast.ModuleName;
alias ModuleMap = Map[ModuleName, Module];

[...S | countValues(...S) >= 1 and allValues?(String?, ...S)]
overload ModuleName(...components: S)
    = ModuleName(Vector[String](...mapValues(String, ...components)));

overload ModuleName(astName: Vector[ast.Identifier])
    = ModuleName(map(x => x.str, astName));

record GlobalLiteralCode(kind:ast.LiteralCodeBodyKind, code:ir.LiteralCode);

record Program = referenceType(
    targetInfo: TargetInfo,
    commandlineVariables: HashMap[String, Maybe[String]],
    modules: ModuleMap,
    moduleSearchPath: Vector[String],
    allSymbolHeads: Vector[SymbolHead],
    allAttributes: Vector[Attribute],
    symbolStaticOverloads: Vector[StaticOverload],
    symbolOverloads: Vector[Overload],
    patternStaticOverloads: Vector[StaticOverload],
    patternOverloads: Vector[Overload],
    overloadsDistributed?: Bool,
    allLiteralCodeBodies: Vector[GlobalLiteralCode],
    globalMap: ProgramGlobalMap,
    hooks: ClayHooks,
);

record ProgramGlobalMap (
    constructors: Map[RTGlobal, Vector[ir.Node]],
    globalOrder: Vector[RTGlobal],
);

var mainModuleName = ModuleName("__main__");
var primitivesModuleName = ModuleName("__primitives__");
var preludeModuleName = ModuleName("prelude");

moduleNameString(name:ModuleName) = join('.', name.path);
overload printTo(stream, name:ModuleName) { printTo(stream, moduleNameString(name)); }
mainModule(program:Program) = ref program.modules[mainModuleName];
primitivesModule(program:Program) = ref program.modules[primitivesModuleName];
preludeModule(program:Program) = ref program.modules[preludeModuleName];

record ClayHooks (
    type?: Value,
    POD?: Value,
    typeAlign: Value,

    llType: Value,
    llTypeAlign: Value,
    llSigned: Value,
    llUnsigned: Value,
    llBoolType: Value,
    llIntegerType: Value,
    llFloatType: Value,
    llPointerType: Value,
    llCodePointerType: Value,
    llArrayType: Value,
    llTupleType: Value,
    llUnionType: Value,
    llLiteralCType: Value,

    Bool: Value,
    Char: Value,
    Int: Value,
    Int8: Value,
    Int16: Value,
    Int32: Value,
    Int64: Value,
    UInt: Value,
    UInt8: Value,
    UInt16: Value,
    UInt32: Value,
    UInt64: Value,
    Float32: Value,
    Float64: Value,
    Static: Value,
    Pointer: Value,
    CodePointer: Value,
    ExternalCodePointer: Value,
    StringConstant: Value,

    Ref: Value,
    Const: Value,
    Rvalue: Value,

    CdeclABI: Value,
    StdcallABI: Value,
    ABI?: Value,
    ABISupportsVariadics?: Value,

    plus: Value,
    minus: Value,
    call: Value,
    index: Value,
    staticIndex: Value,
    fieldRef: Value,
    unpack: Value,
    dereference: Value,
    multiply: Value,
    divide: Value,
    quotient: Value,
    remainder: Value,
    add: Value,
    subtract: Value,
    lesser?: Value,
    lesserEquals?: Value,
    greater?: Value,
    greaterEquals?: Value,
    equals?: Value,
    notEquals?: Value,

    case?: Value,

    iterator: Value,
    hasFront?: Value,
    front: Value,
    incFront: Value,

    tupleLiteral: Value,

    assign: Value,
    updateAssign: Value,
    callAssign: Value,
    updateCallAssign: Value,

    initializeFrom: Value,
    destroy: Value,

    captureLambda: Value,
    lambdaCaptures: Value,

    callMain: Value,
);



//
// Module
//

record Module = referenceType(
    program: Program,
    name: ModuleName,
    originalAST: ast.SourceAST,
    ast: ast.SourceAST,
    publicEnvRoot: EnvRoot,
    privateEnvRoot: EnvRoot,
    publicEnv: Map[String, EnvEntry],
    privateEnv: Map[String, EnvEntry],
);

cloneModule(m:Module, name) = Module(
    m.program,
    name,
    ast.SourceAST(),
    ast.SourceAST(),
    cloneEnvRoot(m.publicEnvRoot),
    cloneEnvRoot(m.privateEnvRoot),
    m.publicEnv,
    m.privateEnv,
);

overload Module(program:Program, name:ModuleName) =
    Module(program, name, ast.SourceAST(), ast.SourceAST(),
        allocateRef(EnvRoot), allocateRef(EnvRoot),
        Map[String, EnvEntry](), Map[String, EnvEntry](),
    );

overload printTo(stream, mod:Module) {
    printTo(stream, "module ", moduleNameString(mod.name));
}

overload printReprTo(stream, mod:Module) {
    printTo(stream, "#<module ", moduleNameString(mod.name), ">");
}


//
// top-level item entries
//

alias EvalTable = Map[ValueList, TriState[ValueList]];

record GlobalBinding (kind:ast.BindingKind, ast:ast.SingleGlobalBinding);

variant SymbolHeadAST = ast.Symbol
                      | ast.GlobalAlias
                      | GlobalBinding;

record SymbolHead = referenceType(
    ast: SymbolHeadAST,
    astName: ast.SymbolName,
    module: Module,
    instances: Map[ValueList, EnvEntry],
    evalTable: EvalTable,
    invokeTable: InvokeTable,
    staticOverloads: Vector[StaticOverload],
    overloads: Vector[Overload],
);

overload SymbolHead(a:SymbolHeadAST, name:ast.SymbolName, module:Module) =
    SymbolHead(
        a, name, module, Map[ValueList, EnvEntry](),
        EvalTable(), InvokeTable(),
        Vector[StaticOverload](),
        Vector[Overload](),
    );

symbolHeadHasParams?(x:SymbolHead) {
    return symbolNameHasParams?(x.astName);
}

symbolNameHasParams?(name:ast.SymbolName) {
    ref p = name.params;
    return not (empty?(p.items) and nothing?(p.variadicItem));
}

record Symbol = referenceType(
    head: SymbolHead,
    params: ValueList,
    env: Env,
    body: TriState[ValueList],
    attributes: TriState[ValueList],
    type?: TriState[Bool],
    evalTable: EvalTable,
    invokeTable: InvokeTable,
);

overload Symbol(head:SymbolHead, params:ValueList, env:Env)
    = Symbol(
        head, params, env,
        TriState[ValueList](), TriState[ValueList](),
        TriState[Bool](),
        EvalTable(),
        InvokeTable(),
    );

record PatternVars = referenceType(
    vars: Vector[ast.Identifier],
    variadicVars: Vector[ast.Identifier],
);

record Attribute = referenceType(
    ast: ast.Attribute,
    module: Module,
    patternVars: Maybe[PatternVars],
);

overload Attribute(x:ast.Attribute, module:Module) =
    Attribute(x, module, nothing(PatternVars));

record StaticOverload = referenceType(
    ast: ast.StaticOverload,
    env: Env,
    patternVars: Maybe[PatternVars],
);

overload StaticOverload(x:ast.StaticOverload, env:Env) =
    StaticOverload(x, env, nothing(PatternVars));

record Overload = referenceType(
    ast: ast.Overload,
    env: Env,
    patternVars: Maybe[PatternVars],
);

overload Overload(x:ast.Overload, env:Env) =
    Overload(x, env, nothing(PatternVars));


//
// aliases
//

record Alias = referenceType(
    ast: ast.GlobalAlias,
    env: Env,
    value: TriState[Value],
);

overload Alias(ast, env) = Alias(ast, env, TriState[Value]());


//
// primitives
//

enum PrimitiveKind {
    PRIM_staticInt?,
    PRIM_staticPlus,
    PRIM_staticMinus,
    PRIM_staticAdd,
    PRIM_staticSubtract,
    PRIM_staticMultiply,
    PRIM_staticQuotient,
    PRIM_staticRemainder,
    PRIM_staticIntegers,

    PRIM_staticUInt,
    PRIM_staticInt,
    PRIM_staticChar,

    PRIM_staticBool?,
    PRIM_staticEquals?,
    PRIM_staticNotEquals?,
    PRIM_staticLesser?,
    PRIM_staticLesserEquals?,
    PRIM_staticGreater?,
    PRIM_staticGreaterEquals?,

    PRIM_staticBitand,
    PRIM_staticBitor,
    PRIM_staticBitxor,
    PRIM_staticBitnot,
    PRIM_staticBitshl,
    PRIM_staticBitshr,

    PRIM_staticChar?,
    PRIM_staticString?,
    PRIM_staticStringSize,
    PRIM_staticStringSlice,
    PRIM_staticStringConcat,
    PRIM_staticStringChar,
    PRIM_staticStringChars,
    PRIM_staticStringFromChars,

    PRIM_staticTuple?,
    PRIM_staticTuple,
    PRIM_staticTupleSize,
    PRIM_staticTupleElement,
    PRIM_staticTupleElements,

    PRIM_staticSymbol?,
    PRIM_staticSymbolBody,
    PRIM_staticSymbolAttributes,

    PRIM_staticModule?,
    PRIM_staticModule,
    PRIM_staticModuleMember,
    PRIM_staticModuleMember?,

    PRIM_staticLambda?,

    PRIM_lambdaSymbol?,

    PRIM_lambdaCapturesByReference?,
    PRIM_lambdaCapturesByValue?,
    PRIM_lambdaStateless?,

    PRIM_lambdaString,
    PRIM_lambdaLocation,

    PRIM_returns?,
    PRIM_type,
    PRIM_staticDefined?,
    PRIM_defined?,

    PRIM_staticObserve,
    PRIM_staticError,
    PRIM_staticAssert,

    PRIM_staticName,
    PRIM_staticQualifiedName,

    PRIM_callDefinedForSymbol?,
    PRIM_staticCallDefined?,

    PRIM_staticCountValues,

    PRIM_platformCPUName,
    PRIM_platformCPUFamilyName,
    PRIM_platformCPUPointerBits,
    PRIM_platformName,
    PRIM_platformFamilyName,
    PRIM_platformCodegen,
    PRIM_platformCodegenDialect,

    PRIM_commandlineVariable,

    PRIM_llMangle,

    PRIM_monomorphic?,
    PRIM_monomorphicInputTypes,
}

record Primitive = referenceType(
    kind: PrimitiveKind,
);

enum RTPrimitiveKind {
    RTPRIM_makeCodePointer,
    RTPRIM_makeExternalCodePointer,
    RTPRIM_callCodePointer,
}

record RTPrimitive = referenceType(
    kind: RTPrimitiveKind,
);

procedure primitiveName;
overload primitiveName(kind:PrimitiveKind) {
    var s = printString(kind);
    assert(beginsWith?(s, "PRIM_"));
    return sliceFrom(s, size("PRIM_"));
}
overload primitiveName(p:Primitive) = primitiveName(p.kind);

overload primitiveName(kind:RTPrimitiveKind) {
    var s = printString(kind);
    assert(beginsWith?(s, "RTPRIM_"));
    return sliceFrom(s, size("RTPRIM_"));
}
overload primitiveName(p:RTPrimitive) = primitiveName(p.kind);


//
// environment
//

variant EnvEntry = Value
                 | ValueList
                 | PatternCell
                 | ListPatternCell
                 | Alias
                 | RTExternal
                 | RTGlobal
                 | RTValue
                 | RTValueList
                 | RTLabel
                 ;

overload EnvEntry() = EnvEntry(Value());

variant EnvParent = Env | Module;

record AmbiguousEntry (modules: Vector[Tuple[Module, EnvEntry]]);

variant EnvRootEntry = EnvEntry | AmbiguousEntry;
overload EnvRootEntry() = EnvRootEntry(AmbiguousEntry());

record EnvImport(visibility: ast.VisibilityKind, module: Module, name: String);
overload printTo(stream, imp:EnvImport) {
    if (imp.visibility == ast.VIS_PRIVATE)
        printTo(stream, "private definition ");
    printTo(stream, imp.name, " from module ", imp.module.name);
}

variant SpecificImport = EnvImport
                       | ModuleValue;
overload SpecificImport() = SpecificImport(EnvImport());

overload EnvRootEntry(imp: EnvImport) {
    switch (imp.visibility) {
    case ast.VIS_PRIVATE:
        return EnvRootEntry(privateLookup(imp.module, imp.name));
    case ast.VIS_PUBLIC:
        return EnvRootEntry(publicLookup(imp.module, imp.name));
    default:
        genericError("invalid visibility");
        return EnvRootEntry();
    }
}

overload EnvRootEntry(mv: ModuleValue) = EnvRootEntry(EnvEntry(Value(mv)));

record GeneralImportEntry(module:Module, location:ast.Location);
record SpecificImportEntry(entry:SpecificImport, location:ast.Location);

record EnvRoot = referenceType(
    generalImports: Map[ModuleName, GeneralImportEntry],
    specificImports: Map[String, SpecificImportEntry],
    entries: Maybe[Map[String, EnvRootEntry]],
);

cloneEnvRoot(root:EnvRoot) = EnvRoot(
    root.generalImports,
    root.specificImports,
    nothing(Map[String, EnvRootEntry]),
);

private resolveGeneralEnvRootEntry(entries, entryName, entryList) {
    switch (size(entryList)) {
    case 0:
        return;
    case 1:
        entries[entryName] = EnvRootEntry(entryList[0].1);
        return;
    default:
        entries[entryName] = EnvRootEntry(AmbiguousEntry(entryList));
        return;
    }
}

private resolveGeneralEnvRootEntries(entries, generalImports) {
    var generalEntries = Map[String, Vector[Tuple[Module, EnvEntry]]]();

    for (name, genImport in items(generalImports)) {
        ref module = genImport.module;
        for (entryName, entry in items(module.publicEnv))
            push(generalEntries[entryName], (module, entry));
    }

    for (entryName, entryList in items(generalEntries))
        resolveGeneralEnvRootEntry(entries, entryName, entryList);

    for (name, genImport in items(generalImports)) {
        ref module = genImport.module;
        withLocation(genImport.location, () ref=> {
            ref rootEntries = envRootEntries(module.publicEnvRoot);
            for (entryName, entry in items(rootEntries)) {
                if (null?(lookup(entries, entryName))) {
                    entries[entryName] = entry;
                }
            }
        });
    }
}

private resolveSpecificEnvRootEntries(entries, specificImports) {
    for (entryName, specImport in items(specificImports)) {
        ref entry = specImport.entry;
        withLocation(specImport.location, () ref=> {
            entries[entryName] = EnvRootEntry(*entry);
        });
    }
}

envRootEntries(envRoot: EnvRoot) = ref maybe(envRoot.entries,
    entries ref=> ref entries,
    () ref=> {
        envRoot.entries = Maybe(Map[String, EnvRootEntry]());
        ref entries = just(envRoot.entries);
        resolveGeneralEnvRootEntries(entries, envRoot.generalImports);
        resolveSpecificEnvRootEntries(entries, envRoot.specificImports);
        return ref entries;
    },
);


//
// env pool
//

private record EnvImpl(
    refCount: SizeT,
    parent: EnvParent,
    entries: Map[String, EnvEntry],
);

overload RegularRecord?(static EnvImpl) = false;
overload BitwiseMovedType?(static EnvImpl) = true;
// EnvImpls will only be moved as part of loading them into the pool, so reset
// and destroy need not do anything
overload NotDestroyedType?(static EnvImpl) = true;
overload NotResetType?(static EnvImpl) = true;

private record EnvPool(
    envs: Deque[EnvImpl],
    freeList: Deque[Pointer[EnvImpl]],
);
// we can just drop the pool on the floor since it'll get destroyed only on exit
overload NotDestroyedType?(static EnvPool) = true;
overload NotResetType?(static EnvPool) = true;

private var envPool = EnvPool();

private resetEnvImpl(ei:EnvImpl, parent:EnvParent) {
    ei.refCount = 1;
    ei.parent <-- parent;
}
private freeEnvImpl(ei:EnvImpl) {
    assert(ei.refCount == 0);
    destroy(ei.parent);
    clear(ei.entries);
}

private callbyname allocEnv(parent:EnvParent) {
    if (empty?(envPool.freeList)) {
        push(envPool.envs, EnvImpl(SizeT(1), parent, Map[String,EnvEntry]()));
        return Env(&back(envPool.envs));
    } else {
        var eip = popFront(envPool.freeList);
        resetEnvImpl(eip^, parent);
        return Env(eip);
    }
}
private freeEnv(env:Env) {
    freeEnvImpl(env.__impl__^);
    push(envPool.freeList, env.__impl__);
}

private retainEnv(env:Env) { inc(env.__impl__^.refCount); }
private releaseEnv(env:Env) {
    dec(env.__impl__^.refCount);
    if (env.__impl__^.refCount == 0)
        freeEnv(env);
}

record Env(__impl__: Pointer[EnvImpl]);
overload fieldRef(env:Env, static #parent)  = ref env.__impl__^.parent;
overload fieldRef(env:Env, static #entries) = ref env.__impl__^.entries;

overload RegularRecord?(static Env) = false;
overload BitwiseMovedType?(static Env) = true;

overload Env() = Env(null(EnvImpl));
overload Env(env:Env) returned:Env {
    returned.__impl__ <-- env.__impl__;
    retainEnv(returned);
}
overload resetUnsafe(env:Env) { env.__impl__ = null(EnvImpl); }
overload destroy(env:Env) {
    if (not null?(env.__impl__))
        releaseEnv(env);
}
overload assign(to:Env, lvalue from:Env) {
    if (to.__impl__ != from.__impl__) {
        releaseEnv(to);
        to.__impl__ = from.__impl__;
        retainEnv(to);
    }
}

overload equals?(a:Env, b:Env) = a.__impl__ == b.__impl__;

newEnv(parent:EnvParent) = allocEnv(parent);
[E | VariantMember?(EnvParent, E)]
overload newEnv(parent:E) = allocEnv(EnvParent(parent));


//
// envModule, envAdd, moduleAdd
//

procedure envModule;
overload envModule(env:Env) Module = envModule(*env.parent);
overload envModule(m:Module) = m;
overload envModule(env:EnvParent) = envModule(*env);

envAdd(env:Env, name:ast.Identifier, forward entry) {
    if (contains?(env.entries, name.str))
        genericError("name redefined: ", name.str);
    env.entries[name.str] = EnvEntry(entry);
}

moduleAdd(module:Module, menv:Map[String, EnvEntry], name:ast.Identifier, forward entry) {
    if (contains?(module.publicEnv, name.str) or contains?(module.privateEnv, name.str))
        genericError("name redefined: ", name.str);
    menv[name.str] = EnvEntry(entry);
}

private envRootReset(envRoot) {
    if (just?(envRoot.entries))
        envRoot.entries = nothing(Map[String, EnvRootEntry]);
}

envRootAddGeneral(envRoot:EnvRoot, module:Module, location:ast.Location) {
    if (not null?(lookup(envRoot.generalImports, module.name)))
        genericError("redundant import of module ", module.name);
    envRoot.generalImports[module.name] = GeneralImportEntry(module, location);
    envRootReset(envRoot);
}

[I | VariantMember?(SpecificImport, I)]
envRootAddSpecific(envRoot:EnvRoot, asName:String, entry:I, location:ast.Location) {
    envRootAddSpecific(envRoot, asName, SpecificImport(entry), location);
}
overload envRootAddSpecific(envRoot:EnvRoot, asName:String, entry:SpecificImport, location:ast.Location) {
    var specImport = lookup(envRoot.specificImports, asName);
    if (null?(specImport))
        envRoot.specificImports[asName] = SpecificImportEntry(entry, location);
    else
        genericError("import of ", entry, " as ", asName, " conflicts with import of ", specImport^.entry, " as ", asName);

    envRootReset(envRoot);
}


//
// publicLookup, privateLookup, nameRefLookup
//

private procedure _ifPublicLookup;

private _ifEnvLookup(_ifParentLookup, fromMod:Maybe[Module], env:Env, name:String, foundFn, notFoundFn) {
    var ptr = lookup(env.entries, name);
    if (null?(ptr))
        return forward ..._ifParentLookup(fromMod, env.parent, name, foundFn, notFoundFn);
    return forward ...foundFn(ptr^);
}

overload _ifPublicLookup(fromMod:Maybe[Module], env:Env, name:String, foundFn, notFoundFn)
    = forward ..._ifEnvLookup(_ifPublicLookup, fromMod, env, name, foundFn, notFoundFn);

private envRootEntryLookup(fromMod:Maybe[Module], name:String, entry:EnvEntry, foundFn, notFoundFn)
    = forward ...foundFn(entry);
overload envRootEntryLookup(fromMod:Maybe[Module], name:String, entry:AmbiguousEntry, foundFn, notFoundFn)
    = forward ...throwButPropagateLike(AmbiguousEntryError(name, entry), ...notFoundFn());

overload _ifPublicLookup(fromMod:Maybe[Module], envRoot:EnvRoot, name:String, foundFn, notFoundFn) {
    ref entries = envRootEntries(envRoot);
    var ptr = lookup(entries, name);
    if (null?(ptr))
        return forward ...notFoundFn();
    else
        return forward ...envRootEntryLookup(fromMod, name, *ptr^, foundFn, notFoundFn);
}

overload _ifPublicLookup(fromMod:Maybe[Module], module:Module, name:String, foundFn, notFoundFn) {
    if (maybe(fromMod, f ref=> f == module, () ref=> false))
        return forward ...notFoundFn();

    var ptr = lookup(module.publicEnv, name);
    if (not null?(ptr))
        return forward ...foundFn(ptr^);

    var newFromMod = maybe(fromMod, f ref=> fromMod, () ref=> Maybe(module));
    return forward ..._ifPublicLookup(newFromMod, module.publicEnvRoot, name, foundFn, notFoundFn);
}

overload _ifPublicLookup(fromMod:Maybe[Module], envParent:EnvParent, name:String, foundFn, notFoundFn)
    = forward ..._ifPublicLookup(fromMod, *envParent, name, foundFn, notFoundFn);

ifPublicLookup(env, name:String, foundFn, notFoundFn)
    = forward ..._ifPublicLookup(nothing(Module), env, name, foundFn, notFoundFn);

publicLookup(env, name) = ref ifPublicLookup(env, name,
    entry ref=> ref entry,
    () ref=> ref throwButPropagate(NameNotFoundError(envModule(env).program, name), EnvEntry),
);
overload publicLookup(env, name:ast.Identifier)
    = forward publicLookup(env, name.str);
overload publicLookup(env, name:StringConstant)
    = forward publicLookup(env, String(name));

publicLookup?(env, name) = ifPublicLookup(env, name, entry => true, () => false);

private _ifPrivateLookup(fromMod:Maybe[Module], env:Env, name:String, foundFn, notFoundFn)
    = forward ..._ifEnvLookup(_ifPrivateLookup, fromMod, env, name, foundFn, notFoundFn);

overload _ifPrivateLookup(fromMod, env:EnvRoot, name, foundFn, notFoundFn)
    = forward ..._ifPublicLookup(fromMod, env, name, foundFn, notFoundFn);

overload _ifPrivateLookup(fromMod:Maybe[Module], module:Module, name:String, foundFn, notFoundFn) {
    if (maybe(fromMod, f ref=> f == module, () ref=> false))
        return forward ...notFoundFn();

    var ptr = lookup(module.privateEnv, name);
    if (not null?(ptr))
        return forward ...foundFn(ptr^);

    ptr = lookup(module.publicEnv, name);
    if (not null?(ptr))
        return forward ...foundFn(ptr^);

    var newFromMod = maybe(fromMod, f ref=> fromMod, () ref=> Maybe(module));

    return forward ..._ifPublicLookup(newFromMod, module.privateEnvRoot, name,
        foundFn,
        () ref=> forward ..._ifPublicLookup(newFromMod, module.publicEnvRoot, name,
            foundFn,
            notFoundFn,
        ),
    );
}


overload _ifPrivateLookup(fromMod, env:EnvParent, name, foundFn, notFoundFn)
    = forward ..._ifPrivateLookup(fromMod, *env, name, foundFn, notFoundFn);

ifPrivateLookup(env, name:String, foundFn, notFoundFn)
    = forward ..._ifPrivateLookup(nothing(Module), env, name, foundFn, notFoundFn);

privateLookup(env, name) = ref ifPrivateLookup(env, name,
    entry ref=> ref entry,
    () ref=> ref throwButPropagate(NameNotFoundError(envModule(env).program, name), EnvEntry),
);
overload privateLookup(env, name:ast.Identifier)
    = forward privateLookup(env, name.str);
overload privateLookup(env, name:StringConstant)
    = forward privateLookup(env, String(name));

privateLookup?(env, name) = ifPrivateLookup(env, name, entry => true, () => false);

nameRefLookup(env, nameRef:ast.NameRef)
    = match(nameRef.env,
        ast.ModuleEnvRef, m ref=> privateLookup(getProgram().modules[m.module], m.name),
        MatchDefault, x ref=> privateLookup(env, nameRef.name),
    );


//
// moduleValueLookup, namePathLookup
//

moduleValueLookup(moduleValue:ModuleValue, member:String) {
    var submoduleValue = lookup(moduleValue.submodules, member);
    if (null?(submoduleValue)) {
        return ref maybe(moduleValue.module,
            module ref=> ref publicLookup(module, member),
            ()     ref=> ref throwButPropagate(GenericError(String("qualified reference to member of module that is not imported")), EnvEntry),
        );
    } else {
        return ref submoduleValue^.envEntry;
    }
}

moduleValueLookup?(moduleValue:ModuleValue, member:String) {
    var submoduleValue = lookup(moduleValue.submodules, member);
    if (null?(submoduleValue)) {
        return maybe(moduleValue.module,
            module ref=> publicLookup?(module, member),
            ()     ref=> false,
        );
    } else {
        return true;
    }
}

private namePathLookupFailureError()
    = ref throwButPropagate(GenericError(printString("tried to access member of non-module value")), EnvEntry);

// XXX this will need to change to support fieldRef syntax
namePathLookup(lookupFn, env, namePath:Vector[ast.Identifier]) {
    assert(size(namePath) > 0);
    var entryp = &lookupFn(env, namePath[0]);

    for (component in slicedFrom(namePath, 1))
        entryp = &match(entryp^,
            Value, v ref=> ref match(v, 
                ModuleValue,  mv ref=> ref moduleValueLookup(mv, component.str),
                MatchDefault, x  ref=> ref namePathLookupFailureError(),
            ),
            MatchDefault, x ref=> ref namePathLookupFailureError(),
        );

    return ref entryp^;
}

overload privateLookup(env, namePath:Vector[ast.Identifier])
    = forward namePathLookup(privateLookup, env, namePath);
overload publicLookup(env, namePath:Vector[ast.Identifier])
    = forward namePathLookup(publicLookup, env, namePath);



//
// ValueList
//

record ValueList(
    data: SharedPointer[Vector[Value]],
);

overload ValueList() = ValueList(new Vector[Value]());

[A | Sequence?(A) and (SequenceElementType(A) == Value)]
overload ValueList(forward a:A) = ValueList(new Vector[Value](a));

[...A | equalValues?(Value, ...A)]
callbyname overload ValueList(...elements:A) =
    ValueList(new Vector[Value](...elements));

[T | VariantMember?(Value, T)]
overload ValueList(forward x:T) = ValueList(Value(x));

overload size(x:ValueList) = size(x.data^);
overload index(x:ValueList, i) = ref index(x.data^, i);
overload begin(x:ValueList) = begin(x.data^);
overload end(x:ValueList) = end(x.data^);
overload iterator(x:ValueList) = iterator(x.data^);
overload push(x:ValueList, forward ...a) { push(x.data^, ...a); }
overload hash(x:ValueList) = hash(x.data^);
overload equals?(a:ValueList, b:ValueList) = equals?(a.data^, b.data^);
overload printTo(stream, x:ValueList) {
    printReprElementsTo(stream, x.data^);
}



//
// Value
//

variant Value = BoolValue
              | CharValue
              | IntValue
              | FloatValue
              | StringValue
              | TupleValue
              | StaticLambdaValue
              | RuntimeLambdaValue
              | ModuleValue

              | SymbolHead
              | Symbol
              | Primitive
              | RTPrimitive
              ;

overload Value() = Value(BoolValue());

record BoolValue(value: Bool);
record CharValue(value: UInt32);
record StringValue(value: String);
record TupleValue(elements: ValueList);

record StaticLambdaValue = referenceType(
    value: ast.LambdaExpr,
    env: Env,
);

record RuntimeLambdaValue = referenceType(
    value: ast.LambdaExpr,
    env: Env,
    invokeTable: InvokeTable,
    lambdaOverload: Maybe[Overload],
);

overload RuntimeLambdaValue(value, env)
    = RuntimeLambdaValue(value, env, InvokeTable(), nothing(Overload));

statelessRuntimeLambda?(l:RuntimeLambdaValue) = empty?(l.value.capturedOrder);

variant IntValue = StaticIntValue | StaticUIntValue
                 |  Int8 |  Int16 |  Int32 |  Int64
                 | UInt8 | UInt16 | UInt32 | UInt64;
variant FloatValue = Float32 | Float64;

overload IntValue() = IntValue(StaticIntValue(0i64));
overload FloatValue() = FloatValue(0.0);


//
// StaticIntValue
//

// XXX use arbitrary-precision int here
record StaticIntValue (value:Int64);
record StaticUIntValue (value:UInt64);

StaticInteger?(X) = false;
overload StaticInteger?(static StaticIntValue) = true;
overload StaticInteger?(static StaticUIntValue) = true;

[SI, I | StaticInteger?(SI) and Integer?(I)]
overload equals?(x:SI, y:I) = x.value == y;
[SI, I | StaticInteger?(SI) and Integer?(I)]
overload equals?(x:I, y:SI) = x == y.value;
[SI, I | StaticInteger?(SI) and Integer?(I)]
overload lesser?(x:SI, y:I) = x.value < y;
[SI, I | StaticInteger?(SI) and Integer?(I)]
overload lesser?(x:I, y:SI) = x < y.value;

[SI, SJ | StaticInteger?(SI) and StaticInteger?(SJ)]
overload equals?(x:SI, y:SJ) = x.value == y.value;
[SI, SJ | StaticInteger?(SI) and StaticInteger?(SJ)]
overload lesser?(x:SI, y:SJ) = x.value < y.value;

overload Int64(x:StaticIntValue)  = x.value;
overload Int64(x:StaticUIntValue) = Int64(x.value);

// work around oldclay compiler bug.
// for some reason it refuses to see a UInt64(StaticIntValue) overload
toUInt64(x) = UInt64(x);
overload toUInt64(x:StaticIntValue)  = UInt64(x.value);
overload toUInt64(x:StaticUIntValue) = x.value;

private StaticIntValueArgs?(I, J)
    = VariantMember?(IntValue, I)
    and VariantMember?(IntValue, J)
    and (StaticInteger?(I) or StaticInteger?(J));

private StaticIntResultType(I, J) = StaticIntValue;
[I]
overload StaticIntResultType(static StaticUIntValue, static I) = StaticUIntValue;
[I]
overload StaticIntResultType(static I, static StaticUIntValue) = StaticUIntValue;

private StaticIntValueType(I, J) = Int64;
[I, J | inValues?(StaticUIntValue, I, J)]
overload StaticIntValueType(static I, static J) = toUInt64;

[I, J | StaticIntValueArgs?(I, J)]
private staticIntMath(fn, x:I, y:J) {
    alias ValueT = StaticIntValueType(I, J);
    alias ResultT = StaticIntResultType(I, J);
    return ResultT(fn(ValueT(x), ValueT(y)));
}

[I, J | StaticIntValueArgs?(I, J)]
overload add(x:I, y:J)       = staticIntMath(add,       x, y);
[I, J | StaticIntValueArgs?(I, J)]
overload subtract(x:I, y:J)  = staticIntMath(subtract,  x, y);
[I, J | StaticIntValueArgs?(I, J)]
overload multiply(x:I, y:J)  = staticIntMath(multiply,  x, y);
[I, J | StaticIntValueArgs?(I, J)]
overload divide(x:I, y:J)    = staticIntMath(divide,    x, y);
[I, J | StaticIntValueArgs?(I, J)]
overload remainder(x:I, y:J) = staticIntMath(remainder, x, y);
[I, J | StaticIntValueArgs?(I, J)]
overload bitwiseAnd(x:I, y:J) = staticIntMath(bitwiseAnd, x, y);
[I, J | StaticIntValueArgs?(I, J)]
overload bitwiseOr(x:I, y:J) = staticIntMath(bitwiseOr, x, y);
[I, J | StaticIntValueArgs?(I, J)]
overload bitwiseXor(x:I, y:J) = staticIntMath(bitwiseXor, x, y);
[I, J | StaticIntValueArgs?(I, J)]
overload shiftLeft(x:I, y:J) = staticIntMath(shiftLeft, x, y);
[I, J | StaticIntValueArgs?(I, J)]
overload shiftRight(x:I, y:J) = staticIntMath(shiftRight, x, y);

[SI | StaticInteger?(SI)]
overload plus(x:SI) = x;
[SI | StaticInteger?(SI)]
overload minus(x:SI) = SI(-x.value);
[SI | StaticInteger?(SI)]
overload bitwiseNot(x:SI) = SI(bitwiseNot(x.value));

// IntValue operations

private applyToIntValue(fn, x, y) = IntValue(fn(x, y));
overload applyToIntValue(fn, x) = IntValue(fn(x));

overload equals?(x:IntValue, y:IntValue) = equals?(*x, *y);
overload lesser?(x:IntValue, y:IntValue) = lesser?(*x, *y);

overload plus (x:IntValue) = applyToIntValue(plus,  *x);
overload minus(x:IntValue) = applyToIntValue(minus, *x);
overload bitwiseNot(x:IntValue) = applyToIntValue(bitwiseNot, *x);

overload add      (x:IntValue, y:IntValue) = applyToIntValue(add,       *x, *y);
overload subtract (x:IntValue, y:IntValue) = applyToIntValue(subtract,  *x, *y);
overload multiply (x:IntValue, y:IntValue) = applyToIntValue(multiply,  *x, *y);
overload divide   (x:IntValue, y:IntValue) = applyToIntValue(divide,    *x, *y);
overload remainder(x:IntValue, y:IntValue) = applyToIntValue(remainder, *x, *y);
overload bitwiseAnd(x:IntValue, y:IntValue) = applyToIntValue(bitwiseAnd, *x, *y);
overload bitwiseOr(x:IntValue, y:IntValue) = applyToIntValue(bitwiseOr, *x, *y);
overload bitwiseXor(x:IntValue, y:IntValue) = applyToIntValue(bitwiseXor, *x, *y);
overload shiftLeft(x:IntValue, y:IntValue) = applyToIntValue(shiftLeft, *x, *y);
overload shiftRight(x:IntValue, y:IntValue) = applyToIntValue(shiftRight, *x, *y);

overload Int64(x:IntValue) = Int64(*x);
overload UInt64(x:IntValue) = UInt64(*x);

// Treat FloatValues as equivalent on bitwise equality, not float equality

private floatValueEquals?(x, y) = false;
[T] overload floatValueEquals?(x:T, y:T) = floatBits(x) == floatBits(y);

private floatValueHash(x) = SizeT(floatBits(x));

overload equals?(x:FloatValue, y:FloatValue) = floatValueEquals?(*x, *y);
overload hash(x:FloatValue) = floatValueHash(*x);


//
// ModuleValue
//

record ModuleValueEntry (envEntry:EnvEntry);
overload ModuleValueEntry() = ModuleValueEntry(EnvEntry(Value(ModuleValue())));

record ModuleValue (
    module: Maybe[Module],
    submodules: Map[String, ModuleValueEntry],
);
moduleValueSubmodule(m:ModuleValue, name:String)
    = ref nestedVariantAs(m.submodules[name].envEntry, ModuleValue);

overload equals?(m1: ModuleValue, m2: ModuleValue)
    = m1.module == m2.module;

overload ModuleValue(module:Module)
    = ModuleValue(Maybe(module), Map[String,ModuleValueEntry]());
overload ModuleValue(module:Maybe[Module])
    = ModuleValue(module, Map[String,ModuleValueEntry]());

qualifiedImportConflictError(path, name) {
    var pathString = join('.', path);
    genericError(
        "qualified import of module ", pathString, ".", name,
        " conflicts with definition ", name,
        " in module ", pathString
    );
}

private checkQualifiedImportConflicts(moduleValue, module) {
    for (name, m in items(moduleValue.submodules))
        if (publicLookup?(module, name))
            qualifiedImportConflictError(module.name.path, name);
}

addModuleValueSubmodule(moduleRef:ModuleValue, path:Vector[String], name:String, module:Maybe[Module]) {
    maybe(moduleRef.module, refModule => {
        if (publicLookup?(refModule, name))
            qualifiedImportConflictError(path, name);
    });

    ref submoduleRef = moduleValueSubmodule(moduleRef, name);
    if (nothing?(submoduleRef.module)) {
        submoduleRef.module = module;
        maybe(module, justModule => {
            checkQualifiedImportConflicts(submoduleRef, justModule);
        });
    } else if (just?(module))
        genericError("conflicting qualified imports for module ", join('.', path), ".", name);
    return ref submoduleRef;
}

overload addModuleValueSubmodule(moduleRef:ModuleValue, path:Vector[String], name:String, module:Module)
    = ref addModuleValueSubmodule(moduleRef, path, name, Maybe(module));
overload addModuleValueSubmodule(moduleRef:ModuleValue, path:Vector[String], name:String)
    = ref addModuleValueSubmodule(moduleRef, path, name, nothing(Module));

private addRootModuleValue(envRoot, moduleName, location) {
    var moduleRefEntry = lookup(envRoot.specificImports, moduleName.path[0]);
    if (null?(moduleRefEntry)) {
        envRootAddSpecific(envRoot, moduleName.path[0], ModuleValue(), location);
        moduleRefEntry = &envRoot.specificImports[moduleName.path[0]];
    } else if (not nestedVariantIs?(moduleRefEntry^.entry, ModuleValue)) {
        genericError(
            "qualified import of module ", moduleName,
            " conflicts with import of definition ", moduleRefEntry^,
            " as ", moduleName.path[0],
        );
    }
    return ref nestedVariantAs(moduleRefEntry^.entry, ModuleValue);
}

addQualifiedModuleValue(envRoot: EnvRoot, module:Module, moduleName:ModuleName, location:ast.Location) {
    assert(size(moduleName.path) > 0);

    if (size(moduleName.path) == 1) {
        ref moduleValue = addRootModuleValue(envRoot, moduleName, location);
        if (just?(moduleValue.module))
            genericError(
                "qualified import of module ", moduleName.path[0],
                " conflicts with import of module ", just(moduleValue.module).name,
                " as ", moduleName.path[0],
            );
        moduleValue.module = Maybe(module);
        checkQualifiedImportConflicts(moduleValue, module);
    } else {
        var moduleRef = &addRootModuleValue(envRoot, moduleName, location);

        var componentPath = Vector[String](moduleName.path[0]);

        var last = size(moduleName.path) - 1;
        for (component in sliced(moduleName.path, 1, last)) {
            moduleRef = &addModuleValueSubmodule(moduleRef^, componentPath, component);
            push(componentPath, component);
        }
        var basename = moduleName.path[last];
        addModuleValueSubmodule(moduleRef^, componentPath, basename, module);
    }
}


//
// print Value
//

private printSymbol(stream, head, params) {
    printTo(stream, head.astName.name.str);
    if (not ast.emptyVariadicList?(head.astName.params))
        printTo(stream, '[', params, ']');
}

printCharReprTo(stream, value:UInt32) {
    if (value == UInt32('\''))
        printTo(stream, "\\'");
    else if (value == UInt32('\"'))
        printTo(stream, "\\\"");
    else if (value >= UInt32(' ') and value <= UInt32('~'))
        printTo(stream, Char(value));
    else if (value == UInt32('\n'))
        printTo(stream, "\\n");
    else if (value == UInt32('\r'))
        printTo(stream, "\\r");
    else if (value == UInt32('\t'))
        printTo(stream, "\\t");
    else if (value == UInt32('\a'))
        printTo(stream, "\\a");
    else if (value == UInt32('\b'))
        printTo(stream, "\\b");
    else if (value == UInt32('\f'))
        printTo(stream, "\\f");
    else if (value == UInt32('\v'))
        printTo(stream, "\\v");
    else if (value == UInt32('\\'))
        printTo(stream, "\\\\");
    else if (value <= 0xffu)
        printTo(stream, "\\x", rightAlignedWith(2, '0', hex(value)));
    else
        printTo(stream, "\\u", rightAlignedWith(6, '0', hex(value)));

}

overload printTo(stream, x:Value) {
    printTo(stream, *x);
}
overload printTo(stream, x:BoolValue) {
    printTo(stream, x.value);
}
overload printTo(stream, c:CharValue) {
    printTo(stream, '\'');
    printCharReprTo(stream, c.value);
    printTo(stream, '\'');
}
overload printTo(stream, v:IntValue) {
    match(v,
        StaticIntValue,  x ref=> { printTo(stream, x.value); },
        StaticUIntValue, x ref=> { printTo(stream, x.value, "u"); },
        UInt8,  x ref=> { printTo(stream, x, "u8" ); },
        UInt16, x ref=> { printTo(stream, x, "u16"); },
        UInt32, x ref=> { printTo(stream, x, "u32"); },
        UInt64, x ref=> { printTo(stream, x, "u64"); },
        Int8,   x ref=> { printTo(stream, x, "i8" ); },
        Int16,  x ref=> { printTo(stream, x, "i16"); },
        Int32,  x ref=> { printTo(stream, x, "i32"); },
        Int64,  x ref=> { printTo(stream, x, "i64"); },
    );
}
overload printTo(stream, v:FloatValue) {
    match(v,
        Float32, x ref=> { printTo(stream, x, "f32"); },
        Float64, x ref=> { printTo(stream, x, "f64"); },
    );
}
overload printTo(stream, x:StringValue) {
    printTo(stream, '\"');
    for (c in utf8Iterator(x.value))
        printCharReprTo(stream, UInt32(c));
    printTo(stream, '\"');
}
overload printTo(stream, x:TupleValue) {
    printTo(stream, "[");
    var commaOut = CommaListPrinter(&stream);
    for (element in x.elements)
        newItem(commaOut, element);
    printTo(stream, "]");
}

private shortExpressionString?(string)
    = size(string) < 80 and find(string, '\n') == end(string);

overload printTo(stream, x:StaticLambdaValue) {
    var expression = ast.getSourceString(x.value);
    if (shortExpressionString?(expression))
        printTo(stream, expression);
    else {
        var path, line, column = ...ast.getFileLocation(x.value);
        printTo(stream, "<lambda ", path, "(", line, ",", column, ")>");
    }
}

overload printTo(stream, x:RuntimeLambdaValue) {
    var expression = ast.getSourceString(x.value);
    if (shortExpressionString?(expression))
        printTo(stream, expression);
    else {
        var path, line, column = ...ast.getFileLocation(x.value);
        printTo(stream, "<lambda ", path, "(", line, ",", column, ")>");
    }
}

overload printTo(stream, x:SymbolHead) {
    printTo(stream, x.astName.name.str);
}
overload printTo(stream, x:Symbol) {
    printSymbol(stream, x.head, x.params);
}
overload printTo(stream, x:ModuleValue) {
    maybe(x.module,
        module ref=> { printTo(stream, module.name); },
        ()     ref=> { printTo(stream, "<incomplete module name>"); },
    );
}
overload printTo(stream, x:Primitive) {
    printTo(stream, primitiveName(x.kind));
}

overload printTo(stream, x:RTPrimitive) {
    printTo(stream, primitiveName(x.kind));
}

[T | VariantMember?(Value, T)]
overload printReprTo(stream, x:T) {
    printTo(stream, x);
}

overload printReprTo(stream, x:Value) {
    printReprTo(stream, *x);
}

overload printReprTo(stream, x:RTGlobal) {
    printSymbol(stream, x.head, x.params);
}


//
// Pattern
//

variant Pattern = Value
                | PatternCell
                | SymbolPattern
                | AliasPattern
                | TuplePattern
                ;

record PatternCell = referenceType(
    value: Maybe[Value]
);

record SymbolPattern = referenceType(
    head: SymbolHead,
    params: ListPattern,
);

record TuplePattern = referenceType(
    elements: ListPattern,
);

record AliasPattern = referenceType(
    pattern: Pattern,
    cellsPattern: ListPattern,
    argsPattern: ListPattern,
);

overload Pattern() = Pattern(Value());

overload printTo(stream, x:PatternCell) {
    maybe(x.value,
        value ref=> { printTo(stream, value); },
        ()    ref=> { printTo(stream, "<uninitialized pattern cell>"); }
    );
}

overload printTo(stream, x:SymbolPattern) {
    printTo(stream, x.head, "[", x.params, "]");
}



//
// ListPattern
//

record ListPattern = referenceType(
    patterns: Vector[Pattern],
    variadicPattern: ListPatternCell,
);

record ListPatternCell = referenceType(
    values: Maybe[ValueList],
);

overload printTo(stream, x:ListPattern) {
    var commaOut = CommaListPrinter(&stream);
    for (element in x.patterns)
        newItem(commaOut, element);

    maybe(x.variadicPattern.values,
        values ref=> {
            for (value in values)
                newItem(commaOut, value);
        },
        ()    ref=> { printTo(stream, "...<uninitialized pattern cell>"); }
    );
}



//
// RTExternal
//

record RTExternalAttributes = referenceType(
    symbolName: String,
    abi: Value,
    variadic?: Bool,
    argumentTypes: ValueList,
    returnType: Maybe[Value],
);

record RTExternal = referenceType(
    ast: ast.ExternalProcedure,
    module: Module,
    name: String,
    externalAttributes: Maybe[RTExternalAttributes],
);

overload printTo(stream, x:RTExternal) {
    printTo(stream, "external ", x.name);
}


//
// RTGlobal
//

record RTGlobal = referenceType(
    head: SymbolHead,
    params: ValueList,
    env: Env,
    attributes: TriState[RTGlobalAttributes],
);

overload RTGlobal(head:SymbolHead, params:ValueList, env:Env)
    = RTGlobal(
        head,
        params,
        env,
        TriState[RTGlobalAttributes]()
    );

record RTGlobalAttributes (
    type: Value,
);


//
// RTValue, RTValueList
//

enum RTValueKind {
    RT_VALUE_CONST,
    RT_VALUE_REF,
    RT_VALUE_RVALUE,
}

record ReferenceVariable();
record LocalVariable();

variant RTValueReferent = ReferenceVariable
                        | LocalVariable
                        | Value
                        | RTGlobal
                        | RTExternal;

overload RTValueReferent() = RTValueReferent(ReferenceVariable());

record RTValue = referenceType(
    kind: RTValueKind,
    type: Value,
    referent: RTValueReferent,
    name: Maybe[String],
);

equalArgument?(v:RTValue, w:RTValue) = v.kind == w.kind and v.type == w.type;

equalArguments?(vs:RTValues, ws:RTValues) {
    if (size(vs) != size(ws))
        return false;
    for (v, w in zipped(vs, ws))
        if (not equalArgument?(v, w))
            return false;
    return true;
}

globalVariable?(v:RTValue) = variantIs?(v.referent, RTGlobal);
localVariable?(v:RTValue) = variantIs?(v.referent, LocalVariable);
referenceVariable?(v:RTValue) = variantIs?(v.referent, ReferenceVariable);
variable?(v:RTValue) = localVariable?(v) or referenceVariable?(v);
immediateValue?(v:RTValue)
    = variantIs?(v.referent, RTExternal) or variantIs?(v.referent, Value);

equalResult?(v:RTValue, w:RTValue)
    = v.kind == w.kind and v.type == w.type and localVariable?(v) == localVariable?(w);

equalResults?(vs:RTValues, ws:RTValues) {
    if (size(vs) != size(ws))
        return false;
    for (v, w in zipped(vs, ws))
        if (not equalResult?(v, w))
            return false;
    return true;
}

overload RTValue(kind:RTValueKind, type:Value) =
    RTValue(kind, type, ReferenceVariable(), nothing(String));
overload RTValue(kind:RTValueKind, type:Value, referent) =
    RTValue(kind, type, RTValueReferent(referent), nothing(String));
[S | String?(S)]
overload RTValue(kind:RTValueKind, type:Value, referent, forward name:S) =
    RTValue(kind, type, RTValueReferent(referent), Maybe(String(name)));
overload RTValue(kind:RTValueKind, type:Value, referent, name:ast.Identifier) =
    RTValue(kind, type, RTValueReferent(referent), name.str);
[R | VariantMember?(RTValueReferent, R)]
overload RTValue(kind:RTValueKind, type:Value, referent:R, name:Maybe[String]) =
    RTValue(kind, type, RTValueReferent(referent), name);

overload RTValue(kind:RTValueKind, type:Value, referent:RTValueReferent, name:Maybe[String])
    returned:RTValue
{
    if (not symbolType?(typeSymbol(type))) {
        genericError("invalid type: ", type);
        return RTValue();
    }
    returned <-- allocateUninitializedRefUnsafe(RTValue);
    returned.kind <-- kind;
    returned.type <-- type;
    returned.referent <-- referent;
    returned.name <-- name;
}

record RTValueList = referenceType(
    vars: Vector[RTValue],
    name: Maybe[String],
);

overload RTValueList(vars:Vector[RTValue]) = RTValueList(vars, nothing(String));
[S | String?(S)]
overload RTValueList(vars:Vector[RTValue], forward name:S)
    = RTValueList(vars, Maybe(String(name)));
overload RTValueList(vars:Vector[RTValue], name:ast.Identifier)
    = RTValueList(vars, name.str);

record RTLabel = referenceType(
    ast: ast.LabelDef,
    breakTarget: ir.BreakTargetId,
    continueTarget: ir.BreakTargetId,
);
overload RTLabel(ast, target) = RTLabel(ast, target, target);


//
// Specialization, InvokeTable
//

alias RTValues = Vector[RTValue];

record Specialization = referenceType(
    matchedOverload: Overload,
    callable: Value,
    args: RTValues,
    results: Maybe[RTValues],
    env: Env,
    body: Maybe[Vector[ir.Node]],
    internalArgs: RTValues,
    internalNamedResults: RTValues,
    inline?: Bool,
);

overload Specialization(o:Overload, callable:Value) {
    var s = allocateRef(Specialization);
    s.matchedOverload = o;
    s.callable = callable;
    s.inline? = false;
    return move(s);
}

overload Specialization(callable:Value) = Specialization(Overload(), callable);

overload printTo(stream, s:Specialization) {
    maybe(s.results,
        results ref=> { printTo(stream, "return ", ResultList(results)); },
        () ref=> { printTo(stream, "noreturn"); },
    );
}

record InvokeEntry(
    specialization: Maybe[Specialization],
);

alias InvokeTable = Map[ArgumentList, InvokeEntry];


//
// ArgumentList equality adapter
//

record ArgumentList(args:RTValues);

overload equals?(a:ArgumentList, b:ArgumentList)
    = equalArguments?(a.args, b.args);

overload hash(a:ArgumentList)
    = hash(map(arg => (arg.kind, arg.type), a.args));

printRTValueKindTo(stream, kind) {
    switch (kind) {
    case RT_VALUE_REF:
        printTo(stream, "ref ");
        break;
    case RT_VALUE_RVALUE:
        printTo(stream, "rvalue ");
        break;
    case RT_VALUE_CONST:
        printTo(stream, "const ");
        break;
    default:
        assert(false);
        break;
    }
}

overload printTo(stream, a:ArgumentList) {
    printTo(stream, "(");
    interleave(a.args,
        () ref=> { printTo(stream, ", "); },
        v ref=> {
            if (staticType?(v.type))
                printTo(stream, "#", staticTypeValue(v.type));
            else {
                printRTValueKindTo(stream, v.kind);
                printTo(stream, v.type);
            }
        },
    );
    printTo(stream, ")");
}

record ResultList(results:RTValues);

overload equals?(a:ResultList, b:ResultList)
    = equalResults?(a.results, b.results);

overload hash(a:ResultList)
    = hash(map(arg => (arg.kind, arg.type, localVariable?(arg)), a.args));

overload printTo(stream, a:ResultList) {
    interleave(a.results,
        () ref=> { printTo(stream, ", "); },
        v ref=> {
            if (not localVariable?(v))
                printRTValueKindTo(stream, v.kind);
            printTo(stream, v.type);
        }
    );
}



//
// safeInitialize
//

[T]
safeInitialize(x:TriState[T], initializer) {
    return triStateInitialize(x, initializer, () => {
        genericError("recursion during initialization");
    });
}



//
// program stack
//

private var _programStack = Stack[Program]();

withProgram(program:Program, f) =
    forward ...withStackValue(_programStack, program, f);

getProgram() = ref stackTop(_programStack);
getProgramMainModule() = ref mainModule(getProgram());
getProgramPreludeModule() = ref preludeModule(getProgram());

getHooks() = ref getProgram().hooks;



//
// location stack
//

record LocationEntry (
    tokens: SourceTokens,
    where: SizeT,
);

private var _locationStack = Stack[LocationEntry]();

withLocation(node, f) {
    var x = ast.getLocation(node);
    if (null?(x.tokens) or empty?(x.tokenRange))
        return forward ...f();
    var entry = LocationEntry(x.tokens, x.mainToken);
    return forward ...withStackValue(_locationStack, entry, f);
}



//
// compilation stack
//

variant CompilationEntry = SymbolBodyEntry
                         | StaticCallEntry
                         | CallAnalysisEntry
                         | GlobalAnalysisEntry
                         | CallCompilationEntry
                         | StaticMatchEntry
                         | RuntimeMatchEntry
                         ;

record SymbolBodyEntry (
    symbolHead: SymbolHead,
    args: ValueList,
);

record StaticCallEntry (
    callable: Value,
    args: ValueList,
);

record CallAnalysisEntry (
    callable: Value,
    args: RTValues,
);

record GlobalAnalysisEntry (
    global: RTGlobal,
);

record CallCompilationEntry (
    callable: Value,
    args: RTValues,
);

record StaticMatchEntry (
    oload: StaticOverload,
    callable: Value,
    args: ValueList,
);

record RuntimeMatchEntry (
    oload: Overload,
    callable: Value,
    args: RTValues,
);

overload printTo(stream, x:SymbolBodyEntry) {
    printTo(stream, "eval symbol ");
    printReprTo(stream, x.symbolHead);
    if (not ast.emptyVariadicList?(x.symbolHead.astName.params)) {
        printTo(stream, "[");
        printReprElementsTo(stream, x.args);
        printTo(stream, "]");
    }
}

overload printTo(stream, x:StaticCallEntry) {
    printTo(stream, "eval #");
    printReprTo(stream, x.callable);
    printTo(stream, "(");
    printReprElementsTo(stream, x.args);
    printTo(stream, ")");
}

overload printTo(stream, x:CallAnalysisEntry) {
    printTo(stream, "compile ");
    printReprTo(stream, x.callable);
    printTo(stream, ArgumentList(x.args));
}

overload printTo(stream, x:StaticMatchEntry) {
    printTo(stream, "match #");
    printReprTo(stream, x.callable);
    printTo(stream, "(");
    printReprElementsTo(stream, x.args);
    printTo(stream, ") to ");
    var file, line, col = ...ast.getFileLocation(x.oload.ast);
    printTo(stream, file, "(", line, ",", col, ")");
}

overload printTo(stream, x:RuntimeMatchEntry) {
    printTo(stream, "match ");
    printReprTo(stream, x.callable);
    printTo(stream, ArgumentList(x.args));
    printTo(stream, " to ");
    var file, line, col = ...ast.getFileLocation(x.oload.ast);
    printTo(stream, file, "(", line, ",", col, ")");
}

overload printTo(stream, x:ast.SingleBinding) {
    printTo(stream, x.name.name.str);
}
overload printTo(stream, x:ast.MultipleBindingList) {
    interleave(x.names.items,
        () ref=> { printTo(stream, ", "); },
        binding ref=> { printTo(stream, binding.name.str); },
    );
    maybe(x.names.variadicItem, item ref=> {
        if (not empty?(x.names.items))
            printTo(stream, ", ");
        printTo(stream, "...", item.name.str);
    });
}

overload printTo(stream, x:GlobalAnalysisEntry) {
    printTo(stream, "analyze global: ", x.global);
}

overload printTo(stream, x:CallCompilationEntry) {
    printTo(stream, "compile: ");
    printReprTo(stream, x.callable);
    printTo(stream, ArgumentList(x.args));
}

record CompilationTrace (trace?:Bool, traceTime?:Bool, depth:UInt);
private var _traceCompilation = CompilationTrace(false, false, 0u);

traceCompilation(trace?:Bool) { _traceCompilation.trace? = trace?; }
traceTime(trace?:Bool) { _traceCompilation.traceTime? = trace?; }

traceEnter(entry) {
    if (_traceCompilation.trace?) {
        if (_traceCompilation.traceTime?) {
            printTimestampTo(stdout);
            print("  ");
        }

        for (i in range(_traceCompilation.depth))
            print(' ');

        println("[ entering ", entry);

        inc(_traceCompilation.depth);
    }
}

traceExit(entry, results) {
    if (_traceCompilation.trace?) {
        if (_traceCompilation.traceTime?) {
            printTimestampTo(stdout);
            print("  ");
        }

        dec(_traceCompilation.depth);

        for (i in range(_traceCompilation.depth))
            print(' ');
        println("] leaving  ", entry, ", result: ", ...weaveValues(", ", ...results));
    }
}

private var _compilationStack = Stack[CompilationEntry]();

withCompilationEntry(entry:CompilationEntry, f) {
    traceEnter(entry);
    var values = captureValues(...withStackValue(_compilationStack, entry, f));
    traceExit(entry, ...capturedRefs(values));
    return forward ...forwardValues(values);
}

withStaticSymbolBody(head:SymbolHead, args:ValueList, f) {
    var entry = CompilationEntry(SymbolBodyEntry(head, args));
    return forward ...withCompilationEntry(entry, f);
}

withStaticCall(callable:Value, args:ValueList, f) {
    var entry = CompilationEntry(StaticCallEntry(callable, args));
    return forward ...withCompilationEntry(entry, f);
}

withCallAnalysis(callable:Value, args:RTValues, f) {
    var entry = CompilationEntry(CallAnalysisEntry(callable, args));
    return forward ...withCompilationEntry(entry, f);
}

withGlobalAnalysis(global:RTGlobal, f) {
    var entry = CompilationEntry(GlobalAnalysisEntry(global));
    return forward ...withCompilationEntry(entry, f);
}

withCallCompilation(callable:Value, args:RTValues, f) {
    var entry = CompilationEntry(CallCompilationEntry(callable, args));
    return forward ...withCompilationEntry(entry, f);
}

withStaticMatch(oload:StaticOverload, callable:Value, args:ValueList, f) {
    var entry = CompilationEntry(StaticMatchEntry(oload, callable, args));
    return forward ...withCompilationEntry(entry, f);
}

withRuntimeMatch(oload:Overload, callable:Value, args:RTValues, f) {
    var entry = CompilationEntry(RuntimeMatchEntry(oload, callable, args));
    return forward ...withCompilationEntry(entry, f);
}



//
// match results
//

variant MatchResult[T] = MatchSuccess[T]
                       | MatchFailedArgCount
                       | MatchFailedPattern
                       | MatchFailedPredicate;

record MatchSuccess[T] (result:T);
record MatchFailedArgCount ();
record MatchFailedPattern ();
record MatchFailedPredicate ();

[T] overload printTo(stream, x:MatchSuccess[T]) {
    printTo(stream, "matched");
}
overload printTo(stream, x:MatchFailedArgCount) {
    printTo(stream, "wrong number of arguments");
}
overload printTo(stream, x:MatchFailedPattern) {
    printTo(stream, "pattern matching failed");
}
overload printTo(stream, x:MatchFailedPredicate) {
    printTo(stream, "predicate returned false");
}

[T] matchSuccess?(x:MatchResult[T]) = variantIs?(x, MatchSuccess[T]);
[T] matchResult(x:MatchResult[T]) = ref variantAs(x, MatchSuccess[T]).result;



//
// option errors
//

record OptionError (message:String);
instance ClayError = OptionError;

optionError(forward ...msg) { throw OptionError(printString(...msg)); }

overload displayError(e:OptionError) { println(e.message); }


//
// hook initialization error
//

record HookInitializationError (error:UniqueValue[ClayError]);
instance ClayError = HookInitializationError;

hookInitializationError(ex) { throw HookInitializationError(UniqueValue(ex)); }

overload displayError(e:HookInitializationError) {
    println("The compiler failed to find all the hook symbols necessary to initialize Clay.");
    print("  ");
    displayError(e.error^);
}


//
// semantic errors
//

[T]
private SemanticError?(static T) = false;

private semanticError(...fields) = recordWithPredicate(
    SemanticError?,
    programStack: Stack[Program],
    locationStack: Stack[LocationEntry],
    compilationStack: Stack[CompilationEntry],
    ...fields
);

[T, ...A | Record?(T)
           and SemanticError?(T)
           and (Tuple[...RecordFieldTypes(T)] ==
                Tuple[Stack[Program], Stack[LocationEntry], Stack[CompilationEntry], ...A])]
callbyname overload T(...args:A) =
    T(_programStack, _locationStack, _compilationStack, ...args);

variant SemanticError;

instance ClayError = SemanticError;

[T | VariantMember?(SemanticError, T)]
overload Exception(forward e:T) =
    Exception(SemanticError(e));

overload displayError(e:SemanticError) {
    displayError(*e);
}

private _displaySemanticError(locationStack, compilationStack, ...message) {
    if (stackEmpty?(locationStack)) {
        println(...message);
    } else {
        var location = stackTop(locationStack);
        var tokens = location.tokens;
        var offset = tokens.vector[location.where].indexRange.begin;
        errorWithLocation(tokens.file, offset, ...message);
    }
    if (not stackEmpty?(compilationStack)) {
        println("context stack: ");
        for (entry in compilationStack)
            println("    ", entry);
    }
}

displaySemanticError(programStack, locationStack, compilationStack, ...message) {
    if (stackEmpty?(programStack))
        _displaySemanticError(locationStack, compilationStack, ...message);
    else
        withProgram(stackTop(programStack), () ref=> {
            _displaySemanticError(locationStack, compilationStack, ...message);
        });
}


//
// semantic error instances
//

record GenericError = semanticError(
    msg: String,
);

instance SemanticError = GenericError;

record NameNotFoundError = semanticError(
    program:Program,
    missingName:String,
);

instance SemanticError = NameNotFoundError;

record StaticAssertionError = semanticError(
    values:ValueList
);

instance SemanticError = StaticAssertionError;

variant MatchError = MatchFailureError
                   | StaticError
                   ;

instance SemanticError = MatchError;

record MatchFailureError = semanticError(
    msg: String,
);

record StaticError = semanticError(
    values:ValueList
);

overload displayError(e:GenericError) {
    displaySemanticError(e.programStack, e.locationStack, e.compilationStack, e.msg);
}

suggestNameCorrections(program:Program, name:String) {
    var msg = String();

    printTo(msg, "name not found: ", name);

    var suggestions = Vector[ModuleName]();

    for (moduleName, module in items(program.modules)) {
        ifPublicLookup(module, name,
            x  ref=> { push(suggestions, moduleName); },
            () ref=> { },
        );
    }

    if (not empty?(suggestions)) {
        printTo(msg, "\ndid you mean:");
        sort(suggestions);
        for (moduleName in suggestions)
            printTo(msg, "\n  ", moduleName, ".", name);
    }

    return move(msg);
}

overload displayError(e:NameNotFoundError) {
    displaySemanticError(e.programStack, e.locationStack, e.compilationStack,
        suggestNameCorrections(e.program, e.missingName)
    );
}

overload displayError(e:StaticAssertionError) {
    displaySemanticError(e.programStack, e.locationStack, e.compilationStack, PresentStaticErrorValues(e.values));
}

overload displayError(e:MatchError) {
    displayError(*e);
}

overload displayError(e:MatchFailureError) {
    displaySemanticError(e.programStack, e.locationStack, e.compilationStack, e.msg);
}

overload displayError(e:StaticError) {
    displaySemanticError(e.programStack, e.locationStack, e.compilationStack, PresentStaticErrorValues(e.values));
}

private record PresentStaticErrorValues(values:ValueList);
overload printTo(stream, x:PresentStaticErrorValues) {
    for (value in x.values)
        match(value,
            StringValue, sv ref=> { printTo(stream, sv.value); },
            IntValue, iv ref=> { printTo(stream, Int64(iv)); },
            CharValue, cv ref=> { printTo(stream, cv.value); },
            MatchDefault, x ref=> { printTo(stream, x); },
        );
}

record RecursiveAnalysisError = semanticError();

instance SemanticError = RecursiveAnalysisError;

overload displayError(e:RecursiveAnalysisError) {
    var msg = "recursion without base case during type propagation";
    displaySemanticError(e.programStack, e.locationStack, e.compilationStack, msg);
}


record AmbiguousEntryError = semanticError(
    name: String,
    entry: AmbiguousEntry,
);

instance SemanticError = AmbiguousEntryError;

overload displayError(e:AmbiguousEntryError) {
    var msg = printString(
        "name ", e.name, " ambiguously imported from multiple modules:"
    );
    for (m in e.entry.modules)
        printTo(msg, "\n  ", m.0.name);
    printTo(msg, "\nuse \"import module.(name);\" form to disambiguate");
    displaySemanticError(e.programStack, e.locationStack, e.compilationStack, msg);
}


//
// error reporting helpers
//

genericError(...msg) {
    throw GenericError(printString(...msg));
}

matchFailureError(...msg) {
    throw MatchError(MatchFailureError(printString(...msg)));
}

recursiveAnalysisError() {
    throw RecursiveAnalysisError();
}

private valuesStr(n) =
    if (n == 1) "value" else "values";

arityError(expected, received) {
    genericError(
        "expected ", expected, " ", valuesStr(expected),
        ", but received ", received
    );
}

arityError2(minExpected, received) {
    genericError(
        "expected at least ", minExpected, " ", valuesStr(minExpected),
        ", but received ", received
    );
}

ensureArity(expected, received) {
    if (expected != received)
        arityError(expected, received);
}

ensureArity2(minExpected, received) {
    if (minExpected > received)
        arityError2(minExpected, received);
}


//
// visitAST
//

visitASTLeaf(visitor, x) {}

visitASTNode(visitor, node) {
    visitASTFields(visitor, node);
}

visitASTFields(visitor, node) {
    static for (field in ...ast.astFields(node))
        visitAST(visitor, field);
}

visitAST(visitor, x) {
    visitASTLeaf(visitor, x);
}

overload visitAST(visitor, sourceAST: ast.SourceAST) {
    if (not null?(sourceAST))
        for (item in sourceAST.topLevelItems)
            visitAST(visitor, item);
}

[N | ast.ASTNode?(N)]
overload visitAST(visitor, node:N) {
    withLocation(node, () ref=> {
        visitASTNode(visitor, node);
    });
}

[T]
overload visitAST(visitor, v:Vector[T]) {
    for (elt in v)
        visitAST(visitor, elt);
}

[T]
overload visitAST(visitor, v:ast.VariadicList[T]) {
    for (elt in v.items)
        visitAST(visitor, elt);
    visitAST(visitor, v.variadicItem);
}

[V | Variant?(V)]
overload visitAST(visitor, v:V) {
    visitAST(visitor, *v);
}
