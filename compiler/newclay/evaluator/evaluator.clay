import maybe.*;
import newclay.ast as ast;
import newclay.ast.transforms.*;
import newclay.ir as ir;
import newclay.analysis.*;
import newclay.common.*;
import newclay.core.*;
//import newclay.common.(displayError);
import newclay.hooks.*;
import newclay.diagnostics.(computeLocation);
import numbers.floats.*;
import printer.formatter.*;
import strings.encodings.utf8.(UTF8);


//
// parseStringLiteral, parseCharLiteral
//

parseStringLiteral(s) {
    var result = UTF8(String());
    var iter = utf8Iterator(s);
    if (not hasNext?(iter) or next(iter) != UniChar('"'))
        assert(false, "no quote opening string literal");

    while (hasNext?(iter)) {
        var c = next(iter);
        if (c == UniChar('"')) {
            if (hasNext?(iter))
                assert(false, "unescaped quote in string literal");
            return move(result.encoded);
        } else if (c == UniChar('\\')) {
            push(result, parseEscapeChar(iter));
        } else {
            push(result, c);
        }
    }
    assert(false, "no quote closing string literal");
    return String();
}

parseCharLiteral(s) {
    var iter = utf8Iterator(s);
    if (not hasNext?(iter) or next(iter) != UniChar('\''))
        assert(false, "no quote opening char literal");
    if (not hasNext?(iter))
        assert(false, "char literal too small");
    var c = next(iter);
    if (c == UniChar('\''))
        assert(false, "unescaped quot in char literal");
    if (c == UniChar('\\'))
        c = parseEscapeChar(iter);

    if (not hasNext?(iter) or next(iter) != UniChar('\''))
        assert(false, "no quote opening char literal");
    if (hasNext?(iter))
        assert(false, "junk after value in char literal");

    return c;
}

private parseEscapeChar(iter) {
    if (not hasNext?(iter))
        assert(false, "incomplete escape sequence in literal");
    var c = next(iter);
    switch (c) {
    case UniChar('n'): return UniChar('\n');
    case UniChar('r'): return UniChar('\r');
    case UniChar('t'): return UniChar('\t');
    case UniChar('a'): return UniChar('\a');
    case UniChar('b'): return UniChar('\b');
    case UniChar('f'): return UniChar('\f');
    case UniChar('v'): return UniChar('\v');
    case UniChar('\\'): return UniChar('\\');
    case UniChar('\''): return UniChar('\'');
    case UniChar('\"'): return UniChar('\"');
    case UniChar('x'): return parseHexChar(iter);
    case UniChar('u'): return parseUniChar(iter);
    }
    return parseOctalChar(c, iter);
}

private parseHexChar(iter) {
    var a, b = UniChar(), UniChar();

    if (not hasNext?(iter))
        assert(false, "incomplete hex escape sequence in literal");
    a = next(iter);
    if (not hasNext?(iter))
        assert(false, "incomplete hex escape sequence in literal");
    b = next(iter);

    return UniChar(parseHexDigit(a)*16 + parseHexDigit(b));
}

private parseUniChar(iter) {
    var chars = Array[UniChar,6]();
    for (c in chars) {
        if (not hasNext?(iter))
            assert(false, "incomplete unicode escape sequence in literal");
        c = next(iter);
    }

    return UniChar( reduce((a, b) => a*16 + parseHexDigit(b), 0, chars) );
}

private parseHexDigit(x) {
    if ((x >= '0') and (x <= '9'))
        return Int(x) - Int('0');
    if ((x >= 'a') and (x <= 'z'))
        return Int(x) - Int('a') + 10;
    if ((x >= 'A') and (x <= 'Z'))
        return Int(x) - Int('A') + 10;
    assert(false, "invalid hex digit: ", x);
    return -1;
}

private parseOctalChar(a, iter) {
    var b, c = UniChar(), UniChar();

    if (not hasNext?(iter))
        assert(false, "incomplete octal escape sequence in literal");
    b = next(iter);
    if (not hasNext?(iter))
        assert(false, "incomplete octal escape sequence in literal");
    c = next(iter);

    return UniChar(
        parseOctalDigit(a)*8*8 + parseOctalDigit(b)*8 + parseOctalDigit(c)
    );
}

private parseOctalDigit(x) {
    if ((x >= '0') and (x <= '7'))
        return Int(x) - Int('0');
    assert(false, "invalid octal digit: ", x);
    return -1;
}


//
// parseIntLiteral, parseFloatLiteral
//

parseIntLiteral(negative?, s) {
    var number = String(if (negative?) "-" else "");
    var suffix = String();

    for (i, c in enumerated(s)) {
        if (c == 'i' or c == 'u') {
            suffix = sliceFrom(s, i);
            break;
        }
        if (c != '_')
            push(number, c);
    }
    assert(size(number) > 0, "integer literal is empty");
    assert(size(suffix) <= 3, "integer suffix is too large");

    try {
        switch (suffix) {
        case "":
        case "i":
            return IntValue(StaticIntValue(Int64(number)));
        case "u":
            return IntValue(StaticUIntValue(UInt64(number)));
        case "u64":
            return IntValue(UInt64(number));
        case "i64":
            return IntValue(Int64(number));
        case "u32":
            return IntValue(UInt32(number));
        case "i32":
            return IntValue(Int32(number));
        case "u16":
            return IntValue(UInt16(number));
        case "i16":
            return IntValue(Int16(number));
        case "u8":
            return IntValue(UInt8(number));
        case "i8":
            return IntValue(Int8(number));
        default:
            assert(false, "invalid integer literal suffix");
            return IntValue();
        }
    } catch (ex:Error) {
        genericError("invalid integer literal: ", if (negative?) "-" else "", s);
        return IntValue();
    }
}

parseHexFloatLiteral(number, suffix) {
    var neg? = false;
    var negExponent? = false;
    var mantissa = 0_u64;
    var mantissaBits = 0;
    var usedMantissaBits = 0;
    var exponentI = SizeT(0);
    var point = 0;
    var point? = false;

    for (i, c in enumerated(number)) {
        if (c == '-') {
            assert(i == 0, "junk before negative sign in hex float literal");
            neg? = true;
        } else if (c == '+') {
            assert(i == 0, "junk before positive sign in hex float literal");
            neg? = false;
        } else if (c == '.') {
            assert(not point?, "multiple decimal points in hex float literal");
            point? = true;
        } else if (c == 'p' or c == 'P') {
            assert(exponentI == 0, "multiple P markers in hex float literal");
            exponentI = i;
            break;
        } else if (c == 'x') {
            assert(mantissa == 0, "junk before hex designator in hex float literal");
            continue;
        } else {
            if (point?)
                point += 4;
            if (c == '0' and mantissa == 0)
                continue;
            mantissaBits += 4;
            if (c != '0')
                usedMantissaBits = mantissaBits;
            if (mantissaBits <= 64)
                mantissa = bitwiseOr(shiftLeft(mantissa, 4), parseHexDigit(c));
        }
    }

    assert(number[exponentI] == 'p' or number[exponentI] == 'P', "no exponent in hex float literal");

    var exponent = Int(sliceFrom(number, exponentI+1));
    var value = 0.0;

    if (mantissa == 0) {
        value = floatFromParts(neg?, 0, 0u64);
    } else {
        var mantissaLog = log2(mantissa);
        var mantissaExponent = mantissaLog
            + (if (mantissaBits > 64) mantissaBits - 64 else 0)
            - point
            + exponent
            + exponentBias(Double);

        mantissa = shiftLeft(mantissa, 60 - mantissaLog);
        var mantissaShift = 8 + max(0, 1-mantissaExponent);

        if (mantissaShift > 61) {
            mantissaExponent = 0;
            mantissa = 0_u64;
        } else if (mantissaExponent >= 2047) {
            mantissaExponent = 2047;
            mantissa = 0_u64;
        } else {
            var roundBit  = bitwiseAnd(mantissa, shiftLeft(1_u64, mantissaShift-1));
            var roundMask = bitwiseAnd(mantissa, shiftLeft(1_u64, mantissaShift-1) - 1);
            var evenBit   = bitwiseAnd(mantissa, shiftLeft(1_u64, mantissaShift));
            //observe(hex(roundBit), hex(roundMask), hex(evenBit));

            mantissa = shiftRight(mantissa, mantissaShift);

            if (roundBit != 0 and (roundMask != 0 or usedMantissaBits > 60 or evenBit != 0))
                mantissa += 1_u64;

            if (mantissaExponent < 0)
                mantissaExponent = 0;
        }

        //observe(number, neg?, mantissaExponent, rightAlignedWith(13, '0', hex(mantissa)));
        value = floatFromParts(neg?, mantissaExponent, mantissa);
    }

    switch (suffix) {
    case "":
    case "f64":
        return FloatValue(value);
    case "f":
    case "f32":
        return FloatValue(Float(value));
    default:
        assert(false, "invalid float suffix");
        return FloatValue();
    }
}

parseFloatLiteral(negative?, s) {
    var number = String(if (negative?) "-" else "");
    var suffix = String();
    var s2 = slicedFrom(s, 0);

    assert(size(s) > 0, "empty float literal");

    var sz = size(s);
    var hex? = false;

    if (s[sz - 1] == 'f') {
        suffix = sliceFrom(s, sz - 1);
        s2 = slicedUpto(s, sz - 1);
    } else if (sz > 3 and s[sz - 3] == 'f' and (
           (s[sz - 2] == '3' and s[sz - 1] == '2')
        or (s[sz - 2] == '6' and s[sz - 1] == '4')
    )) {
        suffix = sliceFrom(s, sz - 3);
        s2 = slicedUpto(s, sz - 3);
    }

    for (c in s2) {
        if (c != '_') {
            if (c == 'x')
                hex? = true;
            push(number, c);
        }
    }

    if (hex?)
        return parseHexFloatLiteral(number, suffix);
    else
        switch (suffix) {
        case "":
        case "f64":
            return FloatValue(Double(number));
        case "f":
        case "f32":
            return FloatValue(Float(number));
        default:
            assert(false, "invalid float suffix");
            return FloatValue();
        }
}


//
// bindArgs, bindPatternArgs
//

verifyBindingArity(formalArgs, args) {
    if (nothing?(formalArgs.variadicItem))
        ensureArity(size(formalArgs.items), size(args));
    else
        ensureArity2(size(formalArgs.items), size(args));
}

private lambdaArgName(arg) {
    if (just?(arg.kind))
        genericError("reference kind not allowed on lambda evaluated in static context");
    if (just?(arg.type))
        genericError("type not allowed on lambda evaluated in static context");
    return arg.name;
}

private addLambdaArg(env, formalArg:ast.BoundArgument, entry) {
    envAdd(env, lambdaArgName(formalArg), entry);
}
overload addLambdaArg(env, formalArg:ast.StaticArgument, entry:Value) {
    initializePatternVars(env, collectPatternVars(formalArg));
    unify(evaluatePattern(formalArg.pattern, env), entry);
}
overload addLambdaArg(env, formalArg:ast.StaticArgument, entry:ValueList) {
    initializePatternVars(env, collectMultiPatternVars(formalArg));
    unifyList(
        ListPattern(Vector[Pattern](), evaluateListPatternCell(formalArg.pattern, env)),
        entry
    );
}

bindArgs(env, formalArgs, args) {
    verifyBindingArity(formalArgs, args);
    var env2 = newEnv(env);
    var nFixed = size(formalArgs.items);
    for (formalArg, arg in zipped(formalArgs.items, slicedUpto(args, nFixed)))
        addLambdaArg(env2, *formalArg, arg);
    maybe(formalArgs.variadicItem,
        formalArg ref=> {
            addLambdaArg(env2, *formalArg, ValueList(slicedFrom(args, nFixed)));
        },
        () => {}
    );
    return env2;
}

bindPatternArgs(env:Env, formalArgs, args) {
    verifyBindingArity(formalArgs, args);
    var env2 = newEnv(env);
    var nFixed = size(formalArgs.items);
    for (name, arg in zipped(formalArgs.items, slicedUpto(args, nFixed)))
        envAdd(env2, name, PatternCell(Maybe(arg)));
    maybe(formalArgs.variadicItem, name ref=> {
        ref rest = slicedFrom(args, nFixed);
        envAdd(env2, name, ListPatternCell(Maybe(ValueList(rest))));
    });
    return env2;
}

bindPatternArgCells(env:Env, formalArgs) {
    var env2 = newEnv(env);
    var cellsPattern = ListPattern(Vector[Pattern](), ListPatternCell(Maybe(ValueList())));
    for (name in formalArgs.items) {
        var cell = PatternCell(nothing(Value));
        envAdd(env2, name, cell);
        push(cellsPattern.patterns, Pattern(cell));
    }
    maybe(formalArgs.variadicItem, name ref=> {
        var cell = ListPatternCell(nothing(ValueList));
        envAdd(env2, name, cell);
        cellsPattern.variadicPattern = cell;
    });
    return env2, cellsPattern;
}


//
// symbols
//

makeSymbolHeadInstance(x:SymbolHead, params:ValueList) {
    var ptr = lookup(x.instances, params);
    if (not null?(ptr)) {
        return ptr^;
    }
    ref y = x.instances[params];
    var env = bindPatternArgs(newEnv(x.module), x.astName.params, params);
    y = makeSymbolHeadInstance2(x, *x.ast, params, env);
    return y;
}

private makeSymbolHeadInstance2(x:SymbolHead, ast:ast.Symbol, params:ValueList, env:Env)
    = EnvEntry(Value(Symbol(x, params, env)));

overload makeSymbolHeadInstance2(x:SymbolHead, ast:ast.GlobalAlias, params:ValueList, env:Env)
    = EnvEntry(Alias(ast, env));

overload makeSymbolHeadInstance2(x:SymbolHead, binding:GlobalBinding, params:ValueList, env:Env)
    = EnvEntry(RTGlobal(x, params, env));

symbolBody(x:Symbol) {
    return safeInitialize(x.body,
        () ref=> withStaticSymbolBody(x.head, x.params, () ref=>
            maybe(variantAs(x.head.ast, ast.Symbol).expr,
                expr ref=> evaluateExprList(expr, newEnv(x.env)),
                () ref=> ValueList(),
            )
        ),
    );
}

symbolAttributes(x:Symbol) {
    return safeInitialize(x.attributes,
        () ref=> evaluateAttributes(Value(x))
    );
}


//
// evaluateMain
//

evaluateMain() {
    var mainRef = ast.Expr(ast.NameRef(ast.Identifier("Main")));
    var mainCall = ast.Expr(ast.Call(mainRef, ast.ExprList()));
    return evaluateMultiExpr(mainCall, newEnv(getProgramMainModule()));
}



//
// evaluateBool, evaluateBoolCall
//

evaluateBool(expr, env) {
    return withLocation(expr, () ref=> {
        var result = evaluateExpr(expr, env);
        if (not variantIs?(result, BoolValue))
            genericError("expecting a Bool value");
        return variantAs(result, BoolValue).value;
    });
}

evaluateBoolCall(callable:Value, args:ValueList) {
    // FIXME: what about error location?
    var results = evaluateCall(callable, args);
    ensureArity(1, size(results));
    if (not variantIs?(results[0], BoolValue))
        genericError("expecting a Bool value");
    return variantAs(results[0], BoolValue).value;
}



//
// evaluateExpr
//

procedure evaluateExpr;

overload evaluateExpr(x:ast.Expr, env:Env) Value {
    return withLocation(x, () ref=> evaluateExpr(*x, env));
}
overload evaluateExpr(x:ast.BoolLiteral, env) {
    return Value(BoolValue(x.value));
}
overload evaluateExpr(x:ast.IntLiteral, env) {
    return Value(parseIntLiteral(x.negative?, x.value));
}
overload evaluateExpr(x:ast.StringLiteral, env) {
    return Value(StringValue(parseStringLiteral(x.value)));
}
overload evaluateExpr(x:ast.CharLiteral, env) {
    return Value(CharValue(UInt32(parseCharLiteral(x.value))));
}
overload evaluateExpr(x:ast.FloatLiteral, env) {
    genericError("floating-point values not supported in static context");
    return Value();
}
overload evaluateExpr(x:ast.NameRef, env) {
    return envEntryToValue(nameRefLookup(env, x));
}
overload evaluateExpr(x:ast.SimpleNameRef, env) {
    return envEntryToValue(privateLookup(env, x.name));
}
overload evaluateExpr(x:ast.PatternNameRef, env) {
    return derefPattern(env, x.name);
}
overload evaluateExpr(x:ast.TupleExpr, env) {
    return Value(TupleValue(evaluateExprList(x.args, env)));
}
overload evaluateExpr(x:ast.Call, env) {
    var callable = evaluateExpr(x.expr, env);
    return evaluateCallWithOneResult(callable, evaluateExprList(x.args, env));
}
overload evaluateExpr(x:ast.Indexing, env) {
    var indexable = evaluateExpr(x.expr, env);
    var args = evaluateExprList(x.args, env);
    return evaluateIndexing(indexable, args);
}
overload evaluateExpr(x:ast.StaticIndexing, env) {
    var indexable = evaluateExpr(x.expr, env);
    var index = Value(parseIntLiteral(false, x.index.value));
    return evaluateIndexing(indexable, ValueList(index));
}
overload evaluateExpr(x:ast.FieldRef, env) {
    var indexable = evaluateExpr(x.expr, env);
    var field = Value(StringValue(x.field.str));
    return evaluateFieldRef(indexable, field);
}
overload evaluateExpr(x:ast.NotExpr, env) {
    return Value(BoolValue(not evaluateBool(x.expr, env)));
}
overload evaluateExpr(x:ast.AndExpr, env) {
    if (evaluateBool(x.expr1, env))
        return evaluateExpr(x.expr2, env);
    else
        return Value(BoolValue(false));
}
overload evaluateExpr(x:ast.OrExpr, env) {
    if (evaluateBool(x.expr1, env))
        return Value(BoolValue(true));
    else
        return evaluateExpr(x.expr2, env);
}
overload evaluateExpr(x:ast.LambdaExpr, env) {
    return Value(StaticLambdaValue(x, env));
}
overload evaluateExpr(x:ast.IfExpr, env) {
    if (evaluateBool(x.condition, env))
        return evaluateExpr(x.thenPart, env);
    else
        return evaluateExpr(x.elsePart, env);
}
overload evaluateExpr(x:ast.ThrowExpr, env) {
    var errorValue = evaluateExpr(x.value, env);
    return evaluatePrimitiveWithOneResult(PRIM_staticError, ValueList(errorValue));
}
overload evaluateExpr(x:ast.PairExpr, env) {
    var leftValue = Value(StringValue(x.name.str));
    var rightValue = evaluateExpr(x.expr, env);
    return Value(TupleValue(ValueList(leftValue, rightValue)));
}
overload evaluateExpr(x:ast.StaticExpr, env) {
    return evaluateExpr(x.expr, env);
}
overload evaluateExpr(x:ast.UnaryOpExpr, env) {
    var operands = ValueList(evaluateExpr(x.expr, env));
    switch (x.operator) {
    case ast.OP_PLUS:
        return evaluateCallWithOneResult(getHooks().plus, operands);
    case ast.OP_MINUS:
        return evaluateCallWithOneResult(getHooks().minus, operands);
    case ast.OP_UNPACK:
        return evaluateCallWithOneResult(getHooks().unpack, operands);
    case ast.OP_DEREFERENCE:
        return evaluateCallWithOneResult(getHooks().dereference, operands);
    default:
        genericError("operator not allowed in static context");
        return Value();
    }
}

overload evaluateExpr(x:ast.BinaryOpExpr, env) {
    var operands = ValueList(evaluateExpr(x.expr1, env), evaluateExpr(x.expr2, env));

    switch (x.operator) {
    case ast.OP_MULTIPLY:
        return evaluateCallWithOneResult(getHooks().multiply, operands);
    case ast.OP_DIVIDE:
        return evaluateCallWithOneResult(getHooks().divide, operands);
    case ast.OP_QUOTIENT:
        return evaluateCallWithOneResult(getHooks().quotient, operands);
    case ast.OP_REMAINDER:
        return evaluateCallWithOneResult(getHooks().remainder, operands);
    case ast.OP_ADD:
        return evaluateCallWithOneResult(getHooks().add, operands);
    case ast.OP_SUBTRACT:
        return evaluateCallWithOneResult(getHooks().subtract, operands);
    case ast.OP_LESSER?:
        return evaluateCallWithOneResult(getHooks().lesser?, operands);
    case ast.OP_LESSER_EQUALS?:
        return evaluateCallWithOneResult(getHooks().lesserEquals?, operands);
    case ast.OP_GREATER?:
        return evaluateCallWithOneResult(getHooks().greater?, operands);
    case ast.OP_GREATER_EQUALS?:
        return evaluateCallWithOneResult(getHooks().greaterEquals?, operands);
    case ast.OP_EQUALS?:
        return evaluateCallWithOneResult(getHooks().equals?, operands);
    case ast.OP_NOT_EQUALS?:
        return evaluateCallWithOneResult(getHooks().notEquals?, operands);
    default:
        assert(false, "invalid binary operator");
        return Value();
    }
}

private verifyStatementExprStatements(statements) {
    for (statement in statements)
        if (not variantIs?(statement, ast.EmptyStatement))
            genericError("statement expressions in static context not yet supported");
}

overload evaluateExpr(x:ast.StatementExpr, env) {
    verifyStatementExprStatements(x.statements);
    return evaluateExpr(x.expr, env);
}


//
// evaluatePatternExpr
//

[T | VariantMember?(ast.Expr, T)]
evaluatePatternExpr(x:T, env) Value = evaluateExpr(x, env);

overload evaluatePatternExpr(x:ast.Pattern, env)
    = withLocation(x, () ref=> evaluatePatternExpr(*x, env));

overload evaluatePatternExpr(x:ast.IndexingPattern, env) {
    var base = evaluateExpr(x.base, env);
    var args = evaluateListPatternExpr(x.args, env);
    return evaluateIndexing(base, args);
}

overload evaluatePatternExpr(x:ast.TuplePattern, env) {
    var elements = evaluateListPatternExpr(x.elements, env);
    return Value(TupleValue(elements));
}

evaluateListPatternExpr(x:ast.ListPattern, env) ValueList {
    var values = ValueList();
    for (item in x.items)
        push(values, evaluatePatternExpr(item, env));

    maybe(x.variadicItem, varItem ref=> {
        withLocation(varItem, () ref=> {
            push(values, evaluateMultiExpr(*varItem, env));
        });
    });
    return values;
}


//
// envEntryToValue
//

procedure envEntryToValue;

overload envEntryToValue(x:EnvEntry) Value {
    return envEntryToValue(*x);
}
overload envEntryToValue(x:Value) Value {
    return x;
}
overload envEntryToValue(x:ValueList) Value {
    genericError("multi-value used in single value context");
    return Value();
}
overload envEntryToValue(x:PatternCell) Value {
    genericError("pattern variable cannot be used in non-pattern expression");
    return Value();
}
overload envEntryToValue(x:ListPatternCell) Value {
    genericError("pattern variable cannot be used in non-pattern expression");
    return Value();
}
overload envEntryToValue(x:RTExternal) Value {
    genericError("external functions not available in static context");
    return Value();
}
overload envEntryToValue(x:RTGlobal) Value {
    return rtTypeToValue(globalAttributes(x).type);
}
overload envEntryToValue(x:RTValue) Value {
    return rtTypeToValue(x.type);
}
overload envEntryToValue(x:Alias) Value {
    return Value(aliasValue(x));
}
overload envEntryToValue(x:RTValueList) Value {
    genericError("multi-value used in single value context");
    return Value();
}
overload envEntryToValue(x:RTLabel) Value {
    genericError("labels not available in static context");
    return Value();
}

aliasValue(x:Alias) = safeInitialize(x.value,
    () ref=> evaluatePatternExpr(x.ast.value, x.env),
);


//
// rtTypeToValue
//

rtTypeToValue(type) {
    if (not staticType?(type))
        genericError("runtime variable cannot be used at compile time");
    return staticTypeValue(type);
}



//
// evaluateExprList
//

evaluateExprList(exprList, env) {
    var results = ValueList();
    for (item in exprList)
        push(results, evaluateExprListItem(item, env));
    return move(results);
}

evaluateMultiExprList(exprList, env) {
    if (size(exprList) == 1 and variantIs?(exprList[0], ast.Expr))
        return evaluateMultiExpr(*exprList[0], env);
    return evaluateExprList(exprList, env);
}

procedure evaluateExprListItem;

overload evaluateExprListItem(x:ast.ExprListItem, env) {
    return evaluateExprListItem(*x, env);
}
overload evaluateExprListItem(x:ast.SubExprList, env) {
    return evaluateExprList(x.exprList, env);
}
overload evaluateExprListItem(x:ast.Expr, env) {
    return ValueList(evaluateExpr(x, env));
}
overload evaluateExprListItem(x:ast.UnpackExpr, env) {
    return evaluateMultiExpr(x.expr, env);
}

overload evaluateExprListItem(x:ast.StatementExprList, env) {
    verifyStatementExprStatements(x.statements);

    return evaluateExprList(x.exprList, env);
}


//
// evaluateMultiExpr
//

procedure evaluateMultiExpr;

overload evaluateMultiExpr(x, env:Env) {
    genericError("single valued expression used in multi-value context");
    return ValueList();
}
overload evaluateMultiExpr(x:ast.Expr, env:Env) ValueList {
    return withLocation(x, () ref=> evaluateMultiExpr(*x, env));
}
overload evaluateMultiExpr(x:ast.NameRef, env) {
    return envEntryToValueList(nameRefLookup(env, x));
}
overload evaluateMultiExpr(x:ast.SimpleNameRef, env) {
    return envEntryToValueList(privateLookup(env, x.name));
}
overload evaluateMultiExpr(x:ast.PatternNameRef, env) {
    return derefListPattern(env, x.name);
}
overload evaluateMultiExpr(x:ast.Call, env) {
    var callable = evaluateExpr(x.expr, env);
    return evaluateCall(callable, evaluateExprList(x.args, env));
}
overload evaluateMultiExpr(x:ast.StaticExpr, env) {
    return evaluateMultiExpr(x.expr, env);
}
overload evaluateMultiExpr(x:ast.ThrowExpr, env) {
    var errorValue = evaluateExpr(x.value, env);
    return evaluatePrimitive(PRIM_staticError, ValueList(errorValue));
}
overload evaluateMultiExpr(x:ast.UnaryOpExpr, env) {
    var operands = ValueList(evaluateExpr(x.expr, env));
    switch (x.operator) {
    case ast.OP_PLUS:
        return evaluateCall(getHooks().plus, operands);
    case ast.OP_MINUS:
        return evaluateCall(getHooks().minus, operands);
    case ast.OP_UNPACK:
        return evaluateCall(getHooks().unpack, operands);
    case ast.OP_DEREFERENCE:
        return evaluateCall(getHooks().dereference, operands);
    default:
        matchFailureError("operator not allowed in static context");
        return ValueList();
    }
}
overload evaluateMultiExpr(x:ast.StatementExpr, env) {
    verifyStatementExprStatements(x.statements);
    return evaluateMultiExpr(x.expr, env);
}



//
// envEntryToValueList
//

procedure envEntryToValueList;

overload envEntryToValueList(x) {
    genericError("single value used in multi-valued context");
    return ValueList();
}
overload envEntryToValueList(x:EnvEntry) {
    return envEntryToValueList(*x);
}
overload envEntryToValueList(x:ValueList) {
    return x;
}
overload envEntryToValueList(x:PatternCell) {
    genericError("pattern variable cannot be used in non-pattern expression");
    return ValueList();
}
overload envEntryToValueList(x:ListPatternCell) {
    genericError("pattern variable cannot be used in non-pattern expression");
    return ValueList();
}
overload envEntryToValueList(x:RTExternal) {
    genericError("external functions not available in static context");
    return ValueList();
}
overload envEntryToValueList(x:RTGlobal) {
    genericError("single value used in multi-valued context");
    return ValueList();
}
overload envEntryToValueList(x:RTValue) {
    genericError("single value used in multi-valued context");
    return ValueList();
}
overload envEntryToValueList(x:Alias) {
    genericError("single value used in multi-valued context");
    return ValueList();
}
overload envEntryToValueList(x:RTValueList) {
    return ValueList(mapped(v => rtTypeToValue(v.type), x.vars));
}
overload envEntryToValueList(x:RTLabel) {
    genericError("labels not available in static context");
    return ValueList();
}



//
// evaluateCallWithOneResult, evaluateCall
//

evaluateCallWithOneResult(x, args) {
    var results = evaluateCall(x, args);
    ensureArity(1, size(results));
    return move(results[0]);
}

procedure evaluateCall;

overload evaluateCall(x, args) {
    genericError("invalid callee: ", x);
    return ValueList();
}
overload evaluateCall(x:Value, args) {
    return evaluateCall(*x, args);
}
overload evaluateCall(x:StaticLambdaValue, args) {
    return withStaticCall(Value(x), args, () ref=> {
        var env2 = bindArgs(x.env, x.value.args, args);
        return evaluateLambdaCodeBody(*x.value.body, env2);
    });
}
overload evaluateCall(x:RuntimeLambdaValue, args) {
    matchFailureError("runtime lambda symbol cannot be evaluated in static context");
    return ValueList();
}
overload evaluateCall(x:Symbol, args) {
    return memoizeStaticCall(x.evalTable, x.head.module.program, Value(x), args);
}
overload evaluateCall(x:SymbolHead, args) {
    return memoizeStaticCall(x.evalTable, x.module.program, Value(x), args);
}
overload evaluateCall(x:Primitive, args) ValueList {
    return evaluatePrimitive(x.kind, args);
}
overload evaluateCall(x:RTPrimitive, args) ValueList {
    matchFailureError(x, " cannot be evaluated in static context");
    return ValueList();
}

overload evaluateLambdaCodeBody(x, env) {
    genericError("lambda block statement not allowed in static context");
    return ValueList();
}

evaluateLambdaCodeBody(x:ast.ExprCodeBody, env) {
    var exprList = ast.ExprList();
    for (item in x.exprs) {
        withLocation(item, () ref=> {
            if (just?(item.kind))
                genericError("reference returns not allowed in static lambda evaluation");
        });
        push(exprList, item.item);
    }

    return evaluateExprList(exprList, env);
}


//
// evaluateIndexing
//

procedure evaluateIndexing;

overload evaluateIndexing(x, args) {
    matchFailureError("invalid static indexee: ", x);
    return Value();
}
overload evaluateIndexing(x:Value, args) {
    return evaluateIndexing(*x, args);
}
overload evaluateIndexing(x:SymbolHead, args) {
    return envEntryToValue(evaluateIndexingEntry(x, args));
}
overload evaluateIndexing(x:StringValue, args) {
    if (size(args) != 1)
        matchFailureError("string must be indexed with a single Int");
    return evaluatePrimitiveWithOneResult(PRIM_staticStringChar, ValueList(Value(x), args[0]));
}
overload evaluateIndexing(x:TupleValue, args) {
    if (size(args) != 1)
        matchFailureError("tuple must be indexed with a single Int");
    return evaluatePrimitiveWithOneResult(PRIM_staticTupleElement, ValueList(Value(x), args[0]));
}


//
// evaluateIndexingEntry
//

procedure evaluateIndexingEntry;

overload evaluateIndexingEntry(x, args) {
    return EnvEntry(evaluateIndexing(x, args));
}
overload evaluateIndexingEntry(x:Value, args) {
    return evaluateIndexingEntry(*x, args);
}
overload evaluateIndexingEntry(x:SymbolHead, args) {
    verifyBindingArity(x.astName.params, args);
    return makeSymbolHeadInstance(x, args);
}


//
// evaluateFieldRef
//

procedure evaluateFieldRef;

overload evaluateFieldRef(x, field) {
    matchFailureError("invalid field reference: ", x);
    return Value();
}
overload evaluateFieldRef(x:Value, field) {
    return evaluateFieldRef(*x, field);
}
overload evaluateFieldRef(x:ModuleValue, field) {
    return evaluatePrimitiveWithOneResult(PRIM_staticModuleMember, ValueList(Value(x), field));
}



//
// evaluatePattern
//

procedure evaluatePattern;

overload evaluatePattern(x:ast.Pattern, env) Pattern {
    return withLocation(x, () ref=> evaluatePattern(*x, env));
}
overload evaluatePattern(x:ast.BoolLiteral, env) {
    return Pattern(evaluateExpr(x, env));
}
overload evaluatePattern(x:ast.IntLiteral, env) {
    return Pattern(evaluateExpr(x, env));
}
overload evaluatePattern(x:ast.StringLiteral, env) {
    return Pattern(evaluateExpr(x, env));
}
overload evaluatePattern(x:ast.CharLiteral, env) {
    return Pattern(evaluateExpr(x, env));
}
overload evaluatePattern(x:ast.NameRef, env) {
    return Pattern(evaluateExpr(x, env));
}
overload evaluatePattern(x:ast.PatternNameRef, env) {
    return Pattern(lookupPattern(env, x.name));
}
overload evaluatePattern(x:ast.IndexingPattern, env) {
    var base = evaluateExpr(x.base, env);
    return evaluateIndexingPattern(base, x.args, env);
}
overload evaluatePattern(x:ast.TuplePattern, env) {
    var elements = evaluateListPattern(x.elements, env);
    return Pattern(TuplePattern(elements));
}



//
// evaluateIndexingPattern
//

procedure evaluateIndexingPattern;

overload evaluateIndexingPattern(x, argsAst, env) {
    genericError("invalid pattern expression");
    return Pattern();
}
overload evaluateIndexingPattern(x:Value, argsAst, env) {
    return evaluateIndexingPattern(*x, argsAst, env);
}
overload evaluateIndexingPattern(x:SymbolHead, argsAst, env) {
    var args = evaluateListPattern(argsAst, env);
    return evaluateSymbolHeadPattern(*x.ast, x, args);
}

private procedure evaluateSymbolHeadPattern;
overload evaluateSymbolHeadPattern(ast:ast.Symbol, x:SymbolHead, args:ListPattern)
    = Pattern(SymbolPattern(x, args));
overload evaluateSymbolHeadPattern(ast:ast.GlobalAlias, x:SymbolHead, args:ListPattern) {
    var env, cells = ...bindPatternArgCells(newEnv(x.module), x.astName.params);
    return Pattern(AliasPattern(
        evaluatePattern(ast.value, env),
        cells,
        args,
    ));
}
overload evaluateSymbolHeadPattern(ast:GlobalBinding, x:SymbolHead, args:ListPattern) {
    genericError("global variable name cannot be used in pattern");
    return Pattern();
}


//
// evaluateListPattern
//

evaluateListPattern(x:ast.ListPattern, env) ListPattern {
    return ListPattern(
        map(y => evaluatePattern(y, env), x.items),
        maybe(x.variadicItem,
            y => evaluateListPatternCell(y, env),
            () => ListPatternCell(Maybe(ValueList())),
        ),
    );
}



//
// evaluateListPatternCell
//

procedure evaluateListPatternCell;

overload evaluateListPatternCell(x, env) {
    genericError("single value pattern used in multi-pattern context");
    return ListPatternCell();
}
overload evaluateListPatternCell(x:ast.Pattern, env) {
    return withLocation(x, () ref=> evaluateListPatternCell(*x, env));
}
overload evaluateListPatternCell(x:ast.PatternNameRef, env) {
    return lookupListPattern(env, x.name);
}



//
// unify
//

procedure unify;
overload unify(p:Pattern, x:Value) {
    return unify(*p, x);
}
overload unify(p:Value, x:Value) {
    return p == x;
}
overload unify(p:PatternCell, x:Value) {
    return maybe(p.value,
        y ref=> (y == x),
        () ref=> {
            p.value = Maybe(x);
            return true;
        }
    );
}
overload unify(p:SymbolPattern, x:Value) {
    if (not variantIs?(x, Symbol))
        return false;
    var y = variantAs(x, Symbol);
    if (p.head != y.head)
        return false;
    return unifyList(p.params, y.params);
}

overload unify(p:TuplePattern, x:Value) {
    if (not variantIs?(x, TupleValue))
        return false;
    var y = variantAs(x, TupleValue);
    return unifyList(p.elements, y.elements);
}

overload unify(p:AliasPattern, x:Value) {
    if (unify(p.pattern, x)) {
        var cellValues = ValueList();
        for (pat in p.cellsPattern.patterns)
            maybe(variantAs(pat, PatternCell).value,
                value ref=> { push(cellValues, value); },
                () ref=> { genericError("unbound pattern variable in alias"); },
            );
        maybe(p.cellsPattern.variadicPattern.values,
            values ref=> { push(cellValues, values); },
            () ref=> { genericError("unbound variadic pattern variable in alias"); },
        );
        return unifyList(p.argsPattern, cellValues);
    } else
        return false;
}



//
// unifyList
//

procedure unifyList;

[A | SizedSequence?(A) and SequenceElementType(A) == Value]
overload unifyList(listPattern:ListPattern, values:A) {
    if (size(listPattern.patterns) > size(values))
        return false;
    for (pattern, value in zipped(listPattern.patterns, values))
        if (not unify(pattern, value))
            return false;
    var restValues = slicedFrom(values, size(listPattern.patterns));
    return unifyList(listPattern.variadicPattern, restValues);
}

[A | SizedSequence?(A) and SequenceElementType(A) == Value]
overload unifyList(listCell:ListPatternCell, values:A) {
    return maybe(listCell.values,
        v ref=> {
            if (size(v) != size(values))
                return false;
            for (a, b in zipped(v, values))
                if (a != b)
                    return false;
            return true;
        },
        () ref=> {
            listCell.values = Maybe(ValueList(values));
            return true;
        },
    );
}



//
// lookupPattern, derefPattern
//

procedure lookupPattern;

overload lookupPattern(env, name:ast.Identifier) {
    return withLocation(name, () ref=> {
        return lookupPattern(privateLookup(env, name));
    });
}
overload lookupPattern(x) {
    genericError("non pattern variable used as pattern variable");
    return PatternCell();
}
overload lookupPattern(x:EnvEntry) {
    return lookupPattern(*x);
}
overload lookupPattern(x:PatternCell) {
    return x;
}
overload lookupPattern(x:ListPatternCell) {
    genericError("multi-value pattern used in single value context");
    return PatternCell();
}

procedure derefPattern;

overload derefPattern(env, name:ast.Identifier) {
    return withLocation(name, () ref=> {
        return derefPattern(lookupPattern(env, name));
    });
}
overload derefPattern(x:PatternCell) {
    return maybe(x.value,
        y => y,
        () => {
            genericError("unbound pattern variable");
            return Value();
        },
    );
}



//
// lookupListPattern, derefListPattern
//

procedure lookupListPattern;

overload lookupListPattern(env, name:ast.Identifier) {
    return withLocation(name, () ref=> {
        return lookupListPattern(privateLookup(env, name));
    });
}
overload lookupListPattern(x) {
    genericError("non pattern variable used as pattern variable");
    return ListPatternCell();
}
overload lookupListPattern(x:EnvEntry) {
    return lookupListPattern(*x);
}
overload lookupListPattern(x:PatternCell) {
    genericError("single value pattern used in multi-pattern context");
    return ListPatternCell();
}
overload lookupListPattern(x:ListPatternCell) {
    return x;
}

procedure derefListPattern;

overload derefListPattern(env, name:ast.Identifier) {
    return withLocation(name, () ref=> {
        return derefListPattern(lookupListPattern(env, name));
    });
}
overload derefListPattern(x:ListPatternCell) {
    return maybe(x.values,
        y => y,
        () => {
            genericError("unbound pattern variable");
            return ValueList();
        },
    );
}



//
// walkPattern, walkMultiPattern, walkListPattern, etc.
//

procedure walkPattern;
overload walkPattern(x:ast.Pattern, visitor) {
    withLocation(x, () ref=> {
        visitor(x, false);
        walkPattern(*x, visitor);
    });
}
overload walkPattern(x:ast.BoolLiteral, visitor) {}
overload walkPattern(x:ast.CharLiteral, visitor) {}
overload walkPattern(x:ast.IntLiteral, visitor) {}
overload walkPattern(x:ast.StringLiteral, visitor) {}
overload walkPattern(x:ast.NameRef, visitor) {}
overload walkPattern(x:ast.PatternNameRef, visitor) {}
overload walkPattern(x:ast.IndexingPattern, visitor) {
    walkListPattern(x.args, visitor);
}
overload walkPattern(x:ast.TuplePattern, visitor) {
    walkListPattern(x.elements, visitor);
}

procedure walkMultiPattern;
overload walkMultiPattern(x, visitor) {
    genericError("not a multi-valued pattern");
}
overload walkMultiPattern(x:ast.Pattern, visitor) {
    withLocation(x, () ref=> {
        visitor(x, true);
        walkMultiPattern(*x, visitor);
    });
}
overload walkMultiPattern(x:ast.PatternNameRef, visitor) {
}

walkListPattern(x:ast.ListPattern, visitor) {
    for (y in x.items)
        walkPattern(y, visitor);
    maybe(x.variadicItem,
        y ref=> { walkMultiPattern(y, visitor); },
        () => {},
    );
}



//
// walkArgumentPatterns, walkArgumentPattern, walkVariadicArgumentPattern

walkArgumentPatterns(x:ast.VariadicList[ast.Argument], visitor) {
    for (y in x.items)
        walkArgumentPattern(*y, visitor);
    maybe(x.variadicItem,
        x ref=> { walkVariadicArgumentPattern(*x, visitor); },
        () => {},
    );
}

walkArgumentPattern(x:ast.BoundArgument, visitor) {
    maybe(x.type, p ref=> { walkPattern(p, visitor); }, () => {});
}
overload walkArgumentPattern(x:ast.StaticArgument, visitor) {
    walkPattern(x.pattern, visitor);
}

walkVariadicArgumentPattern(x:ast.BoundArgument, visitor) {
    maybe(x.type, p ref=> { walkMultiPattern(p, visitor); }, () => {});
}
overload walkVariadicArgumentPattern(x:ast.StaticArgument, visitor) {
    walkMultiPattern(x.pattern, visitor);
}



//
// PatternVarCollector
//

record PatternVarCollector(
    names: Map[String, Bool],
    vars: Vector[ast.Identifier],
    variadicVars: Vector[ast.Identifier],
);

overload call(x:PatternVarCollector, pattern, variadic?) {
    if (not variantIs?(pattern, ast.PatternNameRef))
        return;
    ref name = variantAs(pattern, ast.PatternNameRef).name;
    if (contains?(x.names, name.str)) {
        if (x.names[name.str] != variadic?) {
            genericError(
                "pattern variable cannot be used in both ",
                "single-value and multi-value context"
            );
        }
    }
    else {
        x.names[name.str] = variadic?;
        if (variadic?)
            push(x.variadicVars, name);
        else
            push(x.vars, name);
    }
}



//
// topLevelItemPatternVars
//

procedure TopLevelItemWithPatternVars?(x) = false;
overload TopLevelItemWithPatternVars?(static Attribute) = true;
overload TopLevelItemWithPatternVars?(static StaticOverload) = true;
overload TopLevelItemWithPatternVars?(static Overload) = true;

private procedure applyCollector;
overload applyCollector(x:ast.Argument, collector) {
    applyCollector(*x, collector);
}
overload applyCollector(x:ast.BoundArgument, collector) {
    walkArgumentPattern(x, collector);
}
overload applyCollector(x:ast.StaticArgument, collector) {
    walkArgumentPattern(x, collector);
}
overload applyCollector(x:Attribute, collector) {
    walkPattern(x.ast.target, collector);
}
overload applyCollector(x:StaticOverload, collector) {
    walkPattern(x.ast.target, collector);
    walkListPattern(x.ast.definition.args, collector);
}
overload applyCollector(x:Overload, collector) {
    walkPattern(x.ast.target, collector);
    walkArgumentPatterns(x.ast.definition.args, collector);
}

collectPatternVars(x) {
    var c = PatternVarCollector();
    applyCollector(x, c);
    return PatternVars(move(c.vars), move(c.variadicVars));
}

collectMultiPatternVars(x) {
    var c = PatternVarCollector();
    walkVariadicArgumentPattern(x, c);
    return PatternVars(move(c.vars), move(c.variadicVars));
}

[T | TopLevelItemWithPatternVars?(T)]
topLevelItemPatternVars(x:T) {
    return maybe(x.patternVars,
        y ref=> y,
        () ref=> {
            var pvars = collectPatternVars(x);
            x.patternVars = Maybe(pvars);
            return pvars;
        },
    );
}



//
// initializeMatch, verifyPatternVars, testPredicate
//

initializePatternVars(env, pvars) {
    for (name in pvars.vars)
        envAdd(env, name, PatternCell(nothing(Value)));
    for (name in pvars.variadicVars)
        envAdd(env, name, ListPatternCell(nothing(ValueList)));
}

initializeMatch(envParent, pvars:PatternVars) env:Env {
    try {
        env <-- newEnv(envParent);
        initializePatternVars(env, pvars);
    } catch (ex) {
        destroy(env);
        throw ex;
    }
}

verifyPatternVars(pvars:PatternVars, env:Env) {
    for (name in pvars.vars)
        derefPattern(env, name);
    for (name in pvars.variadicVars)
        derefListPattern(env, name);
}

testPredicate(predicate:Maybe[ast.Expr], env) {
    return maybe(predicate,
        pred => evaluateBool(pred, env),
        () => true,
    );
}



//
// matchAttribute, matchStaticOverload
//

matchAttribute(x:Attribute, target:Value) Maybe[Env] {
    var pvars = topLevelItemPatternVars(x);
    var env = initializeMatch(x.module, pvars);
    var targetPattern = evaluatePattern(x.ast.target, env);
    if (not unify(targetPattern, target))
        return nothing(Env);
    verifyPatternVars(pvars, env);
    if (not testPredicate(x.ast.predicate, env))
        return nothing(Env);
    return Maybe(env);
}

matchStaticOverload(x:StaticOverload, callable:Value, args:ValueList) MatchResult[Env] {
    var pvars = topLevelItemPatternVars(x);
    var env = initializeMatch(x.env, pvars);
    var callablePattern = evaluatePattern(x.ast.target, env);
    if (not unify(callablePattern, callable))
        return MatchResult[Env](MatchFailedPattern());
    var argsPattern = evaluateListPattern(x.ast.definition.args, env);
    if (not unifyList(argsPattern, args))
        return MatchResult[Env](MatchFailedPattern());
    verifyPatternVars(pvars, env);
    if (not testPredicate(x.ast.definition.predicate, env))
        return MatchResult[Env](MatchFailedPredicate());
    return MatchResult[Env](MatchSuccess(env));
}

valueSymbolHead(v)
    = match(v,
        SymbolHead, s ref=> Maybe(s),
        Symbol, s ref=> Maybe(s.head),
        MatchDefault, x ref=> nothing(SymbolHead),
    );

ifStaticOverload(program:Program, callable:Value, args:ValueList, thenFn, elseFn) {
    var maybeHead = valueSymbolHead(callable);
    if (just?(maybeHead)) {
        ref staticOverloads = if (program.overloadsDistributed?)
                just(maybeHead).staticOverloads
            else
                program.symbolStaticOverloads;
        for (x in reversed(staticOverloads)) {
            var matchEnv = withStaticMatch(x, callable, args,
                () => matchStaticOverload(x, callable, args)
            );
            if (matchSuccess?(matchEnv))
                return forward ...thenFn(x, matchResult(matchEnv));
        }
    }

    for (x in reversed(program.patternStaticOverloads)) {
        var matchEnv = withStaticMatch(x, callable, args,
            () => matchStaticOverload(x, callable, args)
        );
        if (matchSuccess?(matchEnv))
            return forward ...thenFn(x, matchResult(matchEnv));
    }

    return forward ...elseFn();
}


//
// evaluateAttributes
//

evaluateAttributes(target) {
    var values = ValueList();
    for (x in getProgram().allAttributes) {
        var result = matchAttribute(x, target);
        if (not nothing?(result))
            push(values, evaluateExpr(x.ast.body, just(result)));
    }
    return move(values);
}


//
// memoizeStaticCall, evaluateStaticCall
//

memoizeStaticCall(evalTable, program, callable, args) {
    return safeInitialize(evalTable[args],
        () ref=> evaluateStaticCall(program, callable, args)
    );
}

evaluateStaticCall(program, callable, args)
    = withStaticCall(callable, args, () ref=> ifStaticOverload(program, callable, args,
        (oload, env) ref=> evaluateExprList(oload.ast.definition.body, env),
        () ref=> {
            matchFailureError("no matching static overload for ", callable, TupleValue(args));
            return ValueList();
        }
    ));


//
// evaluatePrimitive
//

private oneValue(args) {
    ensureArity(1, size(args));
    return args[0];
}

private twoValues(args) {
    ensureArity(2, size(args));
    return args[0], args[1];
}

private threeValues(args) {
    ensureArity(3, size(args));
    return args[0], args[1], args[2];
}

private oneInt(args) {
    var a = oneValue(args);
    if (not variantIs?(a, IntValue))
        matchFailureError("expecting one integer");
    return variantAs(a, IntValue);
}

private twoInts(args) {
    var a, b = ...twoValues(args);
    if (not variantIs?(a, IntValue) or not variantIs?(b, IntValue))
        matchFailureError("expecting two integers");
    return variantAs(a, IntValue), variantAs(b, IntValue);
}

private oneString(args) {
    var a = oneValue(args);
    if (not variantIs?(a, StringValue))
        matchFailureError("expecting one string");
    return variantAs(a, StringValue).value;
}

private stringInt(args) {
    var a, b = ...twoValues(args);
    if (not variantIs?(a, StringValue)
        or not variantIs?(b, IntValue))
    {
        matchFailureError("expecting a string and an Int");
    }
    return ...(
        variantAs(a, StringValue).value,
        variantAs(b, IntValue),
    );
}

private stringIntInt(args) {
    var a, b, c = ...threeValues(args);
    if (not variantIs?(a, StringValue)
        or not variantIs?(b, IntValue)
        or not variantIs?(c, IntValue))
    {
        matchFailureError("expecting a string and two Ints");
    }
    return ...(
        variantAs(a, StringValue).value,
        variantAs(b, IntValue),
        variantAs(c, IntValue),
    );
}

private nStrings(args) {
    var result = Vector[String]();
    for (i, x in enumerated(args)) {
        if (not variantIs?(x, StringValue))
            matchFailureError("expecting a string, but received: ", x);
        push(result, variantAs(x, StringValue).value);
    }
    return move(result);
}

private nChars(args) {
    var result = UTF8(String());
    for (i, x in enumerated(args)) {
        if (not variantIs?(x, CharValue))
            matchFailureError("expecting a char, but received: ", x);
        push(result, variantAs(x, CharValue).value);
    }
    return move(result.encoded);
}

private oneTuple(args) {
    var a = oneValue(args);
    if (not variantIs?(a, TupleValue))
        matchFailureError("expecting a tuple, but received: ", a);
    return variantAs(a, TupleValue).elements;
}

private tupleInt(args) {
    var a, b = ...twoValues(args);
    if (not variantIs?(a, TupleValue) or not variantIs?(b, IntValue))
        matchFailureError("expecting a tuple and a int");
    return variantAs(a, TupleValue).elements, variantAs(b, IntValue);
}

private oneSymbol(args) {
    var a = oneValue(args);
    if (not variantIs?(a, Symbol))
        matchFailureError("expecting a symbol, but received: ", a);
    return variantAs(a, Symbol);
}

private oneStaticLambda(args) {
    var a = oneValue(args);
    if (variantIs?(a, RuntimeLambdaValue))
        matchFailureError("runtime lambda symbol cannot be evaluated in a static context");
    if (not variantIs?(a, StaticLambdaValue))
        matchFailureError("expecting a lambda, but received: ", a);
    return variantAs(a, StaticLambdaValue);
}

private withOneLambda(args, f) {
    var a = oneValue(args);
    return forward ...match(a,
        StaticLambdaValue, f,
        RuntimeLambdaValue, f,
        MatchDefault, x => {
            matchFailureError("expecting a lambda, but received: ", a);
            return forward ...f(typeToRValue(StaticLambdaValue));
        },
    );
}

private nullary?(arglist) = empty?(arglist.items) and nothing?(arglist.variadicItem);

private oneMonomorphicLambda(args) {
    var l = oneStaticLambda(args);
    var inputs = monomorphicInputTypes(l);
    if (nothing?(inputs))
        matchFailureError("lambda must be monomorphic, but received: ", l);
    return l, just(inputs);
}

private moduleString(args) {
    var moduleValue, stringValue = ...twoValues(args);
    if (not variantIs?(moduleValue, ModuleValue) or not variantIs?(stringValue, StringValue)) {
        matchFailureError("expecting a module and an identifier string");
    }
    return variantAs(moduleValue, ModuleValue), variantAs(stringValue, StringValue);
}

evaluatePrimitiveWithOneResult(kind, args) {
    var results = evaluatePrimitive(kind, move(args));
    ensureArity(1, size(results));
    return move(results[0]);
}

private evaluateStaticCompareEquality(a:Value, b:Value, op) = ValueList(BoolValue(op(a, b)));

private evaluateStaticCompare(a, b, op) {
    matchFailureError("static comparison is only applicable to Bool,Bool; Char,Char; Int,Int; String,String; or Tuple,Tuple arguments");
    return ValueList();
}

[T | inValues?(T, BoolValue, CharValue, StringValue)]
overload evaluateStaticCompare(a:T, b:T, op) = ValueList(BoolValue(op(a.value, b.value)));
overload evaluateStaticCompare(a:IntValue, b:IntValue, op) = ValueList(BoolValue(op(a, b)));

overload evaluateStaticCompare(a:TupleValue, b:TupleValue, op) {
    for (av, bv in zipped(a.elements, b.elements)) {
        if (av != bv)
            return evaluateStaticCompare(*av, *bv, op);
    }
    return ValueList(BoolValue(op(size(a.elements), size(b.elements))));
}

stringSize(s) {
    var sz = 0_i64;
    for (c in utf8Iterator(s))
        inc(sz);
    return sz;
}

private maybeEvaluatePatternExpr(x, env) {
    try {
        return Maybe(evaluatePatternExpr(x, env));
    } catch (ex:GenericError) {
        // XXX this is kind of bogus just to catch unbound pattern var errors
        return nothing(Value);
    }
}

private maybeEvaluateMultiPatternExpr(x, env) {
    try {
        return Maybe(evaluateMultiExpr(*x, env));
    } catch (ex:GenericError) {
        // XXX this is kind of bogus just to catch unbound pattern var errors
        return nothing(ValueList);
    }
}

private withHead(head:Value, expr:Value) = evaluateIndexing(head, ValueList(expr));
overload withHead(head:Value, exprs:ValueList)
    = ValueList(mapped(x ref=> evaluateIndexing(head, ValueList(x)), exprs));

[T]
private withArgKind(maybeExpr:Maybe[T], maybeKind) = maybe(maybeExpr,
    expr ref=> maybe(maybeKind,
        kind ref=> {
            var mhead = nothing(Value);
            switch (kind) {
            case ast.ARG_REF:
                mhead = Maybe(getHooks().Ref);
                break;
            case ast.ARG_RVALUE:
                mhead = Maybe(getHooks().Rvalue);
                break;
            case ast.ARG_FORWARD:
                // not monomorphic
                return nothing(T);
            }

            return maybe(mhead,
                head ref=> Maybe(withHead(head, expr)),
                () ref=> maybeExpr
            );
        },
        () ref=> maybeExpr
    ),
);

private monomorphicArgumentTypes(args:ast.ArgumentList, env:Env) {
    var argTypes = ValueList();

    for (arg in args.items) {
        var argType = match(arg,
            ast.BoundArgument, b ref=> maybe(b.type,
                type ref=> withArgKind(maybeEvaluatePatternExpr(type, env), b.kind),
            ),
            ast.StaticArgument, s ref=> maybe(maybeEvaluatePatternExpr(s.pattern, env),
                value ref=> Maybe(staticType(value)),
            ),
        );
        if (nothing?(argType))
            return nothing(ValueList);
        else
            push(argTypes, just(argType));
    }

    if (just?(args.variadicItem)) {
        var varArgTypes = match(just(args.variadicItem),
            ast.BoundArgument, b ref=> maybe(b.type,
                type ref=> withArgKind(maybeEvaluateMultiPatternExpr(type, env), b.kind),
            ),
            ast.StaticArgument, s ref=> maybe(maybeEvaluateMultiPatternExpr(s.pattern, env),
                values ref=> Maybe(ValueList(mapped(staticType, values))),
            ),
        );
        if (nothing?(varArgTypes))
            return nothing(ValueList);
        else
            push(argTypes, just(varArgTypes));
    }

    return Maybe(argTypes);
}

overload monomorphicInputTypes(_) Maybe[ValueList]
    = nothing(ValueList);
private monomorphicInputTypes(a:Value) Maybe[ValueList]
    = monomorphicInputTypes(*a);
overload monomorphicInputTypes(l:StaticLambdaValue) Maybe[ValueList]
    = monomorphicArgumentTypes(l.value.args, l.env);
overload monomorphicInputTypes(l:RuntimeLambdaValue) Maybe[ValueList]
    = monomorphicArgumentTypes(l.value.args, l.env);

evaluatePrimitive(kind, args) {
    return withStaticCall(Value(Primitive(kind)), args, () ref=> {
        switch (kind) {
        case PRIM_staticInt? : {
            var a = oneValue(args);
            return ValueList(BoolValue(variantIs?(a, IntValue)));
        }
        case PRIM_staticPlus : {
            var a = oneInt(args);
            return ValueList(+a);
        }
        case PRIM_staticMinus : {
            var a = oneInt(args);
            return ValueList(-a);
        }
        case PRIM_staticAdd : {
            var a, b = ...twoInts(args);
            return ValueList(a + b);
        }
        case PRIM_staticSubtract : {
            var a, b = ...twoInts(args);
            return ValueList(a - b);
        }
        case PRIM_staticMultiply : {
            var a, b = ...twoInts(args);
            return ValueList(a * b);
        }
        case PRIM_staticQuotient : {
            var a, b = ...twoInts(args);
            return ValueList(a / b);
        }
        case PRIM_staticRemainder : {
            var a, b = ...twoInts(args);
            return ValueList(a % b);
        }
        case PRIM_staticIntegers : {
            var a = Int64(oneInt(args));
            if (a < 0)
                matchFailureError("expecting a non-negative integer");
            return ValueList(mapped(i => Value(IntValue(StaticIntValue(i))), range(a)));
        }

        case PRIM_staticUInt : {
            var a = oneValue(args);
            return match(a,
                IntValue, iv ref=> ValueList(IntValue(StaticUIntValue(toUInt64(*iv)))),
                CharValue, cv ref=> ValueList(IntValue(StaticUIntValue(UInt64(cv.value)))),
                MatchDefault, x ref=> {
                    matchFailureError("expecting an integer or character, got: ", a);
                    return ValueList();
                },
            );
        }
        case PRIM_staticInt : {
            var a = oneValue(args);
            return match(a,
                IntValue, iv ref=> ValueList(IntValue(StaticIntValue(Int64(*iv)))),
                CharValue, cv ref=> ValueList(IntValue(StaticIntValue(Int64(cv.value)))),
                MatchDefault, x ref=> {
                    matchFailureError("expecting an integer or character, got: ", a);
                    return ValueList();
                },
            );
        }
        case PRIM_staticChar : {
            var a = oneValue(args);
            return match(a,
                IntValue, iv ref=> {
                    var i = toUInt64(*iv);
                    return ValueList(CharValue(UInt32(i)));
                },
                CharValue, cv ref=> ValueList(Value(cv)),
                MatchDefault, x ref=> {
                    matchFailureError("expecting an integer or character, got: ", a);
                    return ValueList();
                },
            );
        }

        case PRIM_staticBool? : {
            var a = oneValue(args);
            return ValueList(BoolValue(variantIs?(a, BoolValue)));
        }
        case PRIM_staticEquals? : {
            var a, b = ...twoValues(args);
            return evaluateStaticCompareEquality(a, b, equals?);
        }
        case PRIM_staticNotEquals? : {
            var a, b = ...twoValues(args);
            return evaluateStaticCompareEquality(a, b, notEquals?);
        }
        case PRIM_staticLesser? : {
            var a, b = ...twoValues(args);
            return evaluateStaticCompare(*a, *b, lesser?);
        }
        case PRIM_staticLesserEquals? : {
            var a, b = ...twoValues(args);
            return evaluateStaticCompare(*a, *b, lesserEquals?);
        }
        case PRIM_staticGreater? : {
            var a, b = ...twoValues(args);
            return evaluateStaticCompare(*a, *b, greater?);
        }
        case PRIM_staticGreaterEquals? : {
            var a, b = ...twoValues(args);
            return evaluateStaticCompare(*a, *b, greaterEquals?);
        }

        case PRIM_staticBitand : {
            var a, b = ...twoInts(args);
            return ValueList(bitwiseAnd(a, b));
        }
        case PRIM_staticBitor : {
            var a, b = ...twoInts(args);
            return ValueList(bitwiseOr(a, b));
        }
        case PRIM_staticBitxor : {
            var a, b = ...twoInts(args);
            return ValueList(bitwiseXor(a, b));
        }
        case PRIM_staticBitnot : {
            var a = oneInt(args);
            return ValueList(bitwiseNot(a));
        }
        case PRIM_staticBitshl : {
            var a, b = ...twoInts(args);
            return ValueList(shiftLeft(a, b));
        }
        case PRIM_staticBitshr : {
            var a, b = ...twoInts(args);
            return ValueList(shiftRight(a, b));
        }

        case PRIM_staticChar? : {
            var a = oneValue(args);
            return ValueList(BoolValue(variantIs?(a, CharValue)));
        }
        case PRIM_staticString? : {
            var a = oneValue(args);
            return ValueList(BoolValue(variantIs?(a, StringValue)));
        }
        case PRIM_staticStringSize : {
            var s = oneString(args);
            return ValueList(IntValue(StaticIntValue(stringSize(s))));
        }
        case PRIM_staticStringSlice : {
            var s, from_, to_ = ...stringIntInt(args);
            var from = Int64(from_);
            var to = Int64(to_);

            if (from < 0)
                matchFailureError("invalid starting index: ", from);
            if (to < from)
                matchFailureError("invalid ending index: ", to);

            var slicedS = UTF8(String());
            var iter = utf8Iterator(s);

            for (i in range(from))
                if (hasNext?(iter))
                    next(iter);
                else
                    matchFailureError("invalid starting index: ", from);

            for (i in range(from, to))
                if (hasNext?(iter))
                    push(slicedS, next(iter));
                else
                    matchFailureError("invalid ending index: ", from);

            return ValueList(StringValue(slicedS.encoded));
        }
        case PRIM_staticStringConcat : {
            var a = nStrings(args);
            var result = String();
            for (s in a)
                push(result, move(s));
            return ValueList(StringValue(move(result)));
        }
        case PRIM_staticStringChar : {
            var s, n_ = ...stringInt(args);
            var n = Int64(n_);

            if (n < 0)
                matchFailureError("invalid index into string: ", n);

            var iter = utf8Iterator(s);
            for (i in range(n))
                if (hasNext?(iter))
                    next(iter);
                else
                    matchFailureError("invalid index into string: ", n);

            if (not hasNext?(iter))
                matchFailureError("invalid index into string: ", n);
            return ValueList(CharValue(UInt32(next(iter))));
        }
        case PRIM_staticStringChars : {
            var s = oneString(args);
            return ValueList(mapped(c => Value(CharValue(UInt32(c))), utf8Iterator(s)));
        }
        case PRIM_staticStringFromChars : {
            var s = nChars(args);
            return ValueList(StringValue(s));
        }

        case PRIM_staticTuple? : {
            var a = oneValue(args);
            return ValueList(BoolValue(variantIs?(a, TupleValue)));
        }
        case PRIM_staticTuple : {
            return ValueList(TupleValue(args));
        }
        case PRIM_staticTupleSize : {
            var a = oneTuple(args);
            return ValueList(IntValue(Int(size(a))));
        }
        case PRIM_staticTupleElement : {
            var a, i_ = ...tupleInt(args);
            var i = Int64(i_);
            if ((i < 0) or (i > size(a)))
                matchFailureError("tuple index out of range");
            return ValueList(a[i]);
        }
        case PRIM_staticTupleElements : {
            return oneTuple(args);
        }

        case PRIM_staticSymbol? : {
            var a = oneValue(args);
            return ValueList(BoolValue(variantIs?(a, Symbol)));
        }
        case PRIM_staticSymbolBody : {
            var a = oneSymbol(args);
            return symbolBody(a);
        }
        case PRIM_staticSymbolAttributes : {
            var a = oneSymbol(args);
            return symbolAttributes(a);
        }
        case PRIM_staticModule : {
            var a = oneValue(args);
            return ValueList(match(a,
                SymbolHead, a ref=> ModuleValue(a.module),
                Symbol, a ref=> ModuleValue(a.head.module),
                Primitive, p ref=> ModuleValue(primitivesModule(getProgram())),
                RTPrimitive, p ref=> ModuleValue(primitivesModule(getProgram())),
                MatchDefault, x ref=> {
                    matchFailureError("expecting a symbol");
                    return ModuleValue();
                },
            ));
        }
        case PRIM_staticModule? : {
            var a = oneValue(args);
            return ValueList(BoolValue(variantIs?(a, ModuleValue)));
        }
        case PRIM_staticModuleMember : {
            var module, member = ...moduleString(args);
            return ValueList(envEntryToValue(moduleValueLookup(module, member.value)));
        }

        case PRIM_staticModuleMember? : {
            var module, member = ...moduleString(args);
            return ValueList(BoolValue(moduleValueLookup?(module, member.value)));
        }

        case PRIM_staticLambda? : {
            var a = oneValue(args);
            return ValueList(BoolValue(variantIs?(a, StaticLambdaValue)));
        }

        case PRIM_lambdaSymbol? : {
            var a = oneValue(args);
            return ValueList(BoolValue(variantIs?(a, RuntimeLambdaValue)));
        }

        case PRIM_lambdaCapturesByReference? : {
            var captureKind = withOneLambda(args, l ref=> l.value.captureKind);
            return ValueList(BoolValue(captureKind == ast.LAMBDA_CAPTURE_BY_REFERENCE));
        }

        case PRIM_lambdaCapturesByValue? : {
            var captureKind = withOneLambda(args, l ref=> l.value.captureKind);
            return ValueList(BoolValue(captureKind == ast.LAMBDA_CAPTURE_BY_VALUE));
        }

        case PRIM_lambdaStateless? : {
            var stateless? = withOneLambda(args, l ref=> empty?(l.value.capturedOrder));
            return ValueList(BoolValue(stateless?));
        }

        case PRIM_lambdaString : {
            var sourceString = withOneLambda(args, l ref=> ast.getSourceString(l.value));
            return ValueList(StringValue(move(sourceString)));
        }

        case PRIM_lambdaLocation : {
            var path, line, column
                = ...withOneLambda(args, l ref=> ...ast.getFileLocation(l.value));

            return ValueList(
                Value(StringValue(path)),
                Value(IntValue(StaticIntValue(Int64(line)))),
                Value(IntValue(StaticIntValue(Int64(column))))
            );
        }

        case PRIM_monomorphic? : {
            var a = oneValue(args);

            return ValueList(BoolValue(just?(monomorphicInputTypes(a))));
        }

        case PRIM_monomorphicInputTypes : {
            var a = oneValue(args);

            return maybe(monomorphicInputTypes(a),
                types ref=> types,
                () ref=> {
                    genericError("value is not a monomorphic function: ", a);
                    return ValueList();
                },
            );
        }

        case PRIM_returns? : {
            var l, inputTypes = ...oneMonomorphicLambda(args);
            return ValueList(BoolValue(just?(rtLambdaResults(l))));
        }

        case PRIM_type : {
            var l, inputTypes = ...oneMonomorphicLambda(args);
            return maybe(rtLambdaResults(l),
                vars ref=> ValueList(map(v => rtReturnToRefType(v), vars)),
                ()   ref=> ValueList(),
            );
        }

        case PRIM_staticDefined? : {
            var callable = oneValue(args);
            var defined? = true;
            try {
                evaluateCall(callable, ValueList());
            } catch (e:MatchError) {
                //displayError(e);
                defined? = false;
            }
            return ValueList(BoolValue(defined?));
        }

        case PRIM_defined? : {
            var l, inputTypes = ...oneMonomorphicLambda(args);
            var defined? = true;
            try {
                rtLambdaResults(l);
            } catch (e:MatchError) {
                //displayError(e);
                defined? = false;
            }
            return ValueList(BoolValue(defined?));
        }

        case PRIM_staticError : {
            throw MatchError(StaticError(args));
        }

        case PRIM_staticObserve : {
            observe(#StaticObserve, args);
            return ValueList(args);
        }

        case PRIM_staticAssert : {
            if (empty?(args))
                matchFailureError("staticAssert requires at least one argument");
            if (args[0] == Value(BoolValue(false))) {
                if (size(args) == 1)
                    throw StaticAssertionError(ValueList(StringValue(String("assertion failure"))));
                else
                    throw StaticAssertionError(ValueList(slicedFrom(args, 1)));
            }
            return ValueList(TupleValue());
        }

        case PRIM_staticName : {
            var a = oneValue(args);
            var s = String();
            printReprTo(s, a);
            return ValueList(StringValue(s));
        }
        case PRIM_staticQualifiedName : {
            var a = oneValue(args);
            return ValueList(StringValue(qualifiedValueString(a)));
        }

        case PRIM_callDefinedForSymbol? : {
            if (size(args) < 1)
                matchFailureError("callDefinedForSymbol? requires at least one argument");
            var callable = args[0];
            var callArgs = map(refTypeToRTArgument, slicedFrom(args, 1));

            var callDefined? = ifOverload(getProgram(), callable, callArgs, s => true, () => false);
            return ValueList(BoolValue(callDefined?));
        }

        case PRIM_staticCallDefined? : {
            if (size(args) < 1)
                matchFailureError("staticCallDefined? requires at least one argument");
            var callable = args[0];
            var callArgs = ValueList(slicedFrom(args,1));

            if (variantIs?(callable, Primitive))
                matchFailureError("staticCallDefined? for primitives not yet supported");

            var callDefined? = ifStaticOverload(getProgram(), callable, callArgs,
                (o, e) => true,
                () => false,
            );
            return ValueList(BoolValue(callDefined?));
        }

        case PRIM_staticCountValues : {
            return ValueList(IntValue(StaticIntValue(Int64(size(args)))));
        }

        case PRIM_platformCPUName :
            return ValueList(StringValue(printString(getProgram().targetInfo.cpu)));

        case PRIM_platformCPUFamilyName :
            return ValueList(StringValue(printString(getProgram().targetInfo.cpuFamily)));

        case PRIM_platformCPUPointerBits :
            return ValueList(IntValue(StaticIntValue(Int64(getProgram().targetInfo.cpuPointerBits))));

        case PRIM_platformName :
            return ValueList(StringValue(printString(getProgram().targetInfo.platform)));

        case PRIM_platformFamilyName :
            return ValueList(StringValue(printString(getProgram().targetInfo.platformFamily)));

        case PRIM_platformCodegen :
            return ValueList(StringValue(String("c")));
        case PRIM_platformCodegenDialect :
            return ValueList(StringValue(printString(getProgram().targetInfo.cDialect)));

        case PRIM_commandlineVariable : {
            var name = oneString(args);
            var valuep = lookup(getProgram().commandlineVariables, name);

            if (null?(valuep))
                return ValueList(BoolValue(false));
            else return maybe(valuep^,
                value ref=> ValueList(StringValue(value)),
                () ref=> ValueList(BoolValue(true)),
            );
        }

        case PRIM_llMangle : {
            var s = oneString(args);
            return ValueList(StringValue(mangleString(s)));
        }

        default : {
            assert(false, "invalid primitive");
            return ValueList();
        }
        }
    });
}

private alnum?(c)
    = (c >= '0' and c <= '9')
      or (c >= 'A' and c <= 'Z')
      or (c >= 'a' and c <= 'z');

mangleString(name) {
    var mangled = String();
    for (c in name)
        if (not alnum?(c))
            printTo(mangled, '_', rightAlignedWith(2, '0', hex(UInt8(c))));
        else
            push(mangled, c);
    return move(mangled);
}

private printQualifiedLambdaTo(stream, l) {
    var path, line, column = ...ast.getFileLocation(l.value);
    printTo(stream, "<lambda ",
        path, "(", line, ",", column, ") ",
        l.env.__impl__,
        ">"
    );
}

printQualifiedTo(stream, value:Value) {
    match(value,
        SymbolHead, s ref=> { printTo(stream, s.module.name, '.', s.astName.name.str); },
        Symbol, s ref=> {
            printQualifiedSymbolTo(stream, s.head, s.params);
        },
        Primitive, p ref=> { printTo(stream, primitivesModuleName, '.', primitiveName(p.kind)); },
        RTPrimitive, p ref=> { printTo(stream, primitivesModuleName, '.', primitiveName(p.kind)); },
        TupleValue, t ref=> {
            printTo(stream, '[');
            interleave(t.elements,
                () ref=> { printTo(stream, ", "); },
                p  ref=> { printQualifiedTo(stream, p); },
            );
            printTo(stream, ']');
        },
        StaticLambdaValue, l ref=> {
            printQualifiedLambdaTo(stream, l);
        },
        RuntimeLambdaValue, l ref=> {
            printQualifiedLambdaTo(stream, l);
        },
        MatchDefault, v ref=> { printTo(stream, v); },
    );
}

printQualifiedSymbolTo(stream, head:SymbolHead, params:ValueList) {
    printTo(stream, head.module.name, '.', head.astName.name.str);
    if (not ast.emptyVariadicList?(head.astName.params)) {
        printTo(stream, '[');
        interleave(params,
            () ref=> { printTo(stream, ", "); },
            p  ref=> { printQualifiedTo(stream, p); },
        );
        printTo(stream, ']');
    }
}

qualifiedValueString(symbol:Value) {
    var ident = String();
    printQualifiedTo(ident, symbol);
    return move(ident);
}

private argKind(kind:Maybe[ast.ArgumentKind]) {
    return maybe(kind,
        k ref=> {
            switch (k) {
            case ast.ARG_REF:
                return RT_VALUE_REF;
            case ast.ARG_RVALUE:
                return RT_VALUE_RVALUE;
            case ast.ARG_CONST:
                return RT_VALUE_CONST;
            default:
                assert(false, "invalid monomorphic argument kind");
                return RT_VALUE_CONST;
            }
        },
        () ref=> RT_VALUE_CONST,
    );
}

private argRTValue(arg:ast.BoundArgument, env)
    = RTValue(argKind(arg.kind), evaluatePatternExpr(just(arg.type), env), ReferenceVariable(), arg.name);

private argRTValueList(arg:ast.BoundArgument, env) {
    var types = evaluateMultiExpr(*just(arg.type), env);
    var kind = argKind(arg.kind);
    return RTValueList(map(t ref=> RTValue(kind, t, ReferenceVariable()), types), arg.name);
}

private bindMonomorphicArgs(l:StaticLambdaValue) {
    var env = newEnv(l.env);
    for (arg in l.value.args.items) {
        match(arg,
            ast.BoundArgument, b ref=> {
                envAdd(env, b.name, argRTValue(b, env));
            },
            ast.StaticArgument, s ref=> {},
        );
    }
    maybe(l.value.args.variadicItem, arg ref=> {
        match(arg,
            ast.BoundArgument, b ref=> {
                envAdd(env, b.name, argRTValueList(b, env));
            },
            ast.StaticArgument, s ref=> {},
        );
    });
    return env;
}

private rtLambdaResults(l:StaticLambdaValue) {
    var body = Vector[ir.Node]();
    var complete? = false;
    var returns = SpecializationReturns();
    var env = bindMonomorphicArgs(l);
    var s = SpecializationContext(&body, &complete?, &returns);
    addEnvRvalues(s, env);

    return analyzeCodeBody(s, env, l.value.body);
}

private addEnvRvalues(s, envParent) {}
overload addEnvRvalues(s, env:Env) {
    for (name, entry in items(env.entries))
        match(entry,
            RTValue, v ref=> {
                addRvalue(s, v);
            },
            RTValueList, vl ref=> {
                for (v in vl.vars)
                    addRvalue(s, v);
            },
            MatchDefault, x ref=> {}
        );
    addEnvRvalues(s, *env.parent);
}

rtReturnToRefType(v) {
    var refSymbolHead = Value();
    switch (v.kind) {
    case RT_VALUE_REF:
        refSymbolHead = getHooks().Ref;
        break;
    case RT_VALUE_CONST:
        refSymbolHead = getHooks().Const;
        break;
    case RT_VALUE_RVALUE:
        if (localVariable?(v) or immediateValue?(v))
            return v.type;

        refSymbolHead = getHooks().Rvalue;
        break;
    }

    return envEntryToValue(makeSymbolHeadInstance(
        variantAs(refSymbolHead, SymbolHead), ValueList(v.type)
    ));
}

private _refTypeToRTValue(
    type:Value,
    referent:RTValueReferent,
    defaultKind:RTValueKind,
    defaultReferent:RTValueReferent
) = match(type,
    Symbol, typeSymbol ref=> {
        if (symbolType?(typeSymbol))
            return RTValue(defaultKind, type, defaultReferent);
        else {
            var refHead = Value(typeSymbol.head);
            if (size(typeSymbol.params) != 1)
                genericError("arguments must be valid types");
            var refTypeSymbol = typeSymbol.params[0];
            var type? = match(refTypeSymbol,
                Symbol, s ref=> symbolType?(s),
                MatchDefault, x ref=> false,
            );
            if (not type?)
                genericError("arguments must be valid types");

            if (refHead == getHooks().Ref)
                return RTValue(RT_VALUE_REF, refTypeSymbol, referent);
            if (refHead == getHooks().Rvalue)
                return RTValue(RT_VALUE_RVALUE, refTypeSymbol, referent);
            if (refHead == getHooks().Const)
                return RTValue(RT_VALUE_CONST, refTypeSymbol, referent);

            genericError("arguments must be valid types");
            return RTValue();
        }
    },
    MatchDefault, x ref=> {
        genericError("arguments must be valid types");
        return RTValue();
    },
);

refTypeToRTArgument(type:Value) = _refTypeToRTValue(
    type,
    RTValueReferent(LocalVariable()),
    RT_VALUE_CONST,
    RTValueReferent(LocalVariable()),
);
refTypeToRTReturn(type:Value) = _refTypeToRTValue(
    type,
    RTValueReferent(ReferenceVariable()),
    RT_VALUE_RVALUE,
    RTValueReferent(LocalVariable()),
);
