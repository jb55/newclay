import newclay.common.*;
import newclay.lexer.*;
import newclay.diagnostics.*;
import maybe.*;
import parsing.combinators.wrapper.*;
import externals.*;
import strings.encodings.utf8.(UTF8);


//
// combinator specialization
//

private var combinators = Combinators[LexerInput]();

private var Parser? = combinators.Parser?;
private var Parsers? = combinators.Parsers?;
private var ParseResult = combinators.ParseResult;

private var nextChar = combinators.nextToken;

private var condition = combinators.condition;
private var literal = combinators.literal;
private var literalString = combinators.literalString;
private var optional = combinators.optional;
private var choice = combinators.choice;
private var sequence = combinators.sequence;
private var sequenceAs = combinators.sequenceAs;
private var modify = combinators.modify;
private var repeated = combinators.repeated;
private var repeatedAs = combinators.repeatedAs;
private var zeroOrMore = combinators.zeroOrMore;
private var oneOrMore = combinators.oneOrMore;
private var zeroOrMoreAs = combinators.zeroOrMoreAs;
private var oneOrMoreAs = combinators.oneOrMoreAs;



//
// utility
//

private alias Dummy = UniChar;
private alias dummy = UniChar('T');

private seq(forward ...parsers) = sequenceAs(dummy, ...parsers);

private zeroPlus(forward ...parsers) = zeroPlus(seq(...parsers));
overload zeroPlus(forward parser) = zeroOrMoreAs(dummy, parser);

private onePlus(forward ...parsers) = onePlus(seq(...parsers));
overload onePlus(forward parser) = oneOrMoreAs(dummy, parser);



//
// bounds combinator
//

[Parser]
private bounds(parser:Parser) {
    return input => {
        alias T = ParseResult(Parser);
        var start = currentByte(input);
        var indexStart = input.current;
        return maybe(parser(input),
            x ref=> {
                x.range = DataRange(start, currentByte(input));
                x.indexRange = DataRange(indexStart, input.current);
                return Maybe(x);
            },
            () => nothing(T),
        );
    };
}



//
// char predicates
//

private decimalDigit?(c) = ((c >= '0') and (c <= '9'));
private hexDigit?(c) = decimalDigit?(c) or
                       ((c >= 'a') and (c <= 'f')) or
                       ((c >= 'A') and (c <= 'F'));
private octalDigit?(c) = ((c >= '0') and (c <= '7'));

private alpha?(c) = ((c >= 'a') and (c <= 'z')) or
                    ((c >= 'A') and (c <= 'Z'));



//
// identifiers and keywords
//

private identChar1?(c) = alpha?(c) or (c == '_');
private identChar2?(c) = identChar1?(c) or decimalDigit?(c) or (c == '?');

private var identChar1 = condition(identChar1?);
private var identChar2 = condition(identChar2?);
private var identStr = seq(identChar1, zeroPlus(identChar2));

private lexIdentifierOrKeyword(input) Maybe[Token] {
    var start = currentByte(input);
    if (not nothing?(identStr(input))) {
        var data = String(sliced(input.file.data, start, currentByte(input)));
        var i = keywordIndex(data);
        if (i >= 0)
            return Maybe(Token(KEYWORD, i));
        return Maybe(Token(IDENTIFIER));
    }
    return nothing(Token);
}



//
// punctuation
//

private lexPunctuation(input) {
    for (i, sym in enumerated(punctuations)) {
        var parser = literalString(UTF8(sym));
        var result = parser(input);
        if (not nothing?(result))
            return Maybe(Token(PUNCTUATION, i));
    }
    return nothing(Token);
}



//
// hexDigit, octalDigit, decimalDigit
//

private var hexDigit = condition(hexDigit?);
private var octalDigit = condition(octalDigit?);
private var decimalDigit = condition(decimalDigit?);



//
// char literal, string literal
//

private var hexEscape = seq(UniChar('x'), hexDigit, hexDigit);
private var unicodeEscape = seq(UniChar('u'),
    hexDigit, hexDigit, hexDigit, hexDigit, hexDigit, hexDigit
);
private var octalEscape = seq(octalDigit, octalDigit, octalDigit);

private var escapeSeq = choice(
    UniChar('n'), UniChar('r'), UniChar('t'), UniChar('a'),
    UniChar('b'), UniChar('f'), UniChar('v'), UniChar('\\'),
    UniChar('\''), UniChar('\"'),
    hexEscape, octalEscape, unicodeEscape
);

private var escapeChar2 = seq(UniChar('\\'), escapeSeq);
private escapeChar(input) = escapeChar2(input);

private var charChar = choice(
    condition(c => (c != '\\' and c != '\'')),
    escapeChar,
);

private var strChar = choice(
    condition(c => (c != '\\' and c != '\"')),
    escapeChar,
);

private var lexCharLiteral = modify(
    x => Token(CHAR_LITERAL),
    seq(UniChar('\''), charChar, UniChar('\'')),
);

private var lexStringLiteral = modify(
    x => Token(STRING_LITERAL),
    seq(UniChar('\"'), zeroPlus(strChar), UniChar('\"')),
);



//
// static index
//

private var lexStaticIndex = modify(
    x => Token(STATIC_INDEX),
    seq(UniChar('.'), intLiteral)
);



//
// int literal
//

private var hexDigits = seq(
    hexDigit, zeroPlus(choice(UniChar('_'), hexDigit))
);

private var hexInt = seq(
    UTF8("0x"), hexDigits,
);

private var decimalInt = seq(
    decimalDigit, zeroPlus(choice(UniChar('_'), decimalDigit))
);

private var sign = choice(UniChar('+'), UniChar('-'));

private var intType = choice(
    seq(UniChar('u'), UniChar('8')),
    seq(UniChar('u'), UniChar('1'), UniChar('6')),
    seq(UniChar('u'), UniChar('3'), UniChar('2')),
    seq(UniChar('u'), UniChar('6'), UniChar('4')),
    seq(UniChar('i'), UniChar('8')),
    seq(UniChar('i'), UniChar('1'), UniChar('6')),
    seq(UniChar('i'), UniChar('3'), UniChar('2')),
    seq(UniChar('i'), UniChar('6'), UniChar('4')),
    UniChar('u'),
    UniChar('i'),
);

private var intLiteral = seq(choice(hexInt, decimalInt), optional(intType));

private var lexIntLiteral = modify(
    x => Token(INT_LITERAL),
    intLiteral
);



//
// float literal
//

private var exponent = seq(choice(UniChar('e'),UniChar('E')), optional(sign), decimalInt);
private var fractional = seq(UniChar('.'), decimalInt);

private var floatTail = choice(
    seq(fractional, optional(exponent)),
    exponent,
);

private var hexExponent = seq(choice(UniChar('p'),UniChar('P')), optional(sign), decimalInt);
private var hexFractional = seq(UniChar('.'), hexDigits);

private var hexFloatTail = choice(
    seq(hexFractional, hexExponent),
    hexExponent,
);

private var decimalFloat = seq(decimalInt, floatTail);
private var hexFloat = seq(hexInt, hexFloatTail);

private var floatType = choice(
    seq(UniChar('f'), UniChar('3'), UniChar('2')),
    seq(UniChar('f'), UniChar('6'), UniChar('4')),
    UniChar('f'),
);

private var lexFloatLiteral = modify(
    x => Token(FLOAT_LITERAL),
    choice(
        seq(choice(hexFloat, decimalFloat), optional(floatType)),
        seq(decimalInt, floatType)
    ),
);



//
// literal code
//

private var literalCodeDelimiter = literalString(UTF8("\"\"\""));

private nonDelimiter(input) {
    var saved = input;
    return maybe(literalCodeDelimiter(input),
        x ref=> {
            input = move(saved);
            return nothing(UniChar);
        },
        () ref=> nextChar(input),
    );
}

private var lexLiteralCode = modify(
    x => Token(LITERAL_CODE),
    seq(literalCodeDelimiter, zeroPlus(nonDelimiter), literalCodeDelimiter),
);



//
// space
//

private space?(c) {
    for (x in " \t\n\r\f\v") {
        if (c == x)
            return true;
    }
    return false;
}

private var lexSpace = modify(
    x => Token(SPACE),
    onePlus(condition(space?)),
);



//
// comments
//

private var notNewline = condition(c => (c != '\n'));

private var lexLineComment = modify(
    x => Token(COMMENT),
    seq(UTF8("//"), zeroPlus(notNewline), optional(UniChar('\n'))),
);

private blockCommentTail(input) {
    var saved = input;
    var lastWasStar = false;
    while (hasNext?(input)) {
        var c = next(input);
        if (lastWasStar and (c == '/'))
            return Maybe(dummy);
        lastWasStar = (c == '*');
    }
    input = saved;
    return nothing(Dummy);
}

private var lexBlockComment = modify(
    x => Token(COMMENT),
    seq(UTF8("/*"), blockCommentTail)
);



//
// lex one token
//

private var lexToken = bounds(choice(
    lexSpace,
    lexLineComment,
    lexBlockComment,
    lexCharLiteral,
    lexStaticIndex,
    lexFloatLiteral,
    lexIntLiteral,
    lexPunctuation,
    lexLiteralCode,
    lexIdentifierOrKeyword,
    lexStringLiteral,
));


//
// tokenize
//

private var lexSentinel = bounds(input => Maybe(Token(SENTINEL)));

private var tokenize1 = modify(
    x => {
        var v = move(x.0);
        push(v, move(x.1));
        return move(v);
    },
    sequence(zeroOrMore(lexToken), lexSentinel),
);

private tokenizeAll(file) {
    var input = LexerInput(file);
    var tokensData = require(tokenize1(input));
    if (currentByte(input) != size(file.data))
        throw LexerError(file, input.maxCurrent);
    return SourceTokens(file, move(tokensData));
}

private impl_tokenize(file:SourceFile) {
    var tokens = tokenizeAll(file);
    tokens.vector = Vector(filtered(
        x => (x.kind != SPACE) and (x.kind != COMMENT),
        tokens.vector,
    ));

    return move(tokens);
}

external lexer_tokenize(
    ex:ExternalException,
    inFile:Pointer[SourceFile],
    out:Pointer[SourceTokens]
) {
    wrapAsExternal(impl_tokenize, static 1, ex, inFile, out);
}

