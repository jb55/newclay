import maybe.*;
import newclay.ast as ast;
import newclay.ast.transforms.(transformLambdaToOverload);
import newclay.ir as ir;
import newclay.core.*;
import newclay.hooks.*;
import newclay.evaluator.*;

record SpecializationContext (
    body: Pointer[Vector[ir.Node]],
    complete?: Pointer[Bool],
    returns: Pointer[SpecializationReturns],
    availableRvalues: HashMap[RTValue, Tuple[]],
);

overload SpecializationContext(body, complete?, returns)
    = SpecializationContext(body, complete?, returns, HashMap[RTValue, Tuple[]]());

private subContext(s:SpecializationContext, subBody:Vector[ir.Node])
    = SpecializationContext(&subBody, s.complete?, s.returns, s.availableRvalues);
private loopSubContext(s:SpecializationContext, subBody:Vector[ir.Node])
    = SpecializationContext(&subBody, s.complete?, s.returns, HashMap[RTValue, Tuple[]]());

record SpecializationReturns (
    results?: Bool,
    results: RTValues,
    namedResults: RTValues,
);

overload SpecializationReturns() = SpecializationReturns(false, RTValues(), RTValues());

addRvalue(s, rv:RTValue) {
    if (rv.kind != RT_VALUE_RVALUE)
        return rv;

    assert(null?(lookup(s.availableRvalues, rv)), "rvalue introduced more than once");
    s.availableRvalues[rv] = ();
    return rv;
}

overload addRvalue(s, mrvs:Maybe[RTValues])
    = maybe(mrvs, rvs ref=> Maybe(map(rv ref=> addRvalue(s, rv), rvs)));

useRvalue(s, rv:RTValue) {
    if (rv.kind != RT_VALUE_RVALUE)
        return;

    if (null?(lookup(s.availableRvalues, rv)))
        genericError("rvalue used more than once");

    remove(s.availableRvalues, rv);
}

private useSubRvalues(s, subS) {
    s.availableRvalues = subS.availableRvalues;
}

private useBranchRvalues(s, branchS1, branchS2) {
    for (rv, x in items(s.availableRvalues)) {
        if (null?(lookup(branchS1.availableRvalues, rv))
            or null?(lookup(branchS2.availableRvalues, rv)))
            remove(s.availableRvalues, rv);
    }
}


//
// externalAttributes, externalRTValue
//

externalRTValue(x:RTExternal) {
    var attrs = externalAttributes(x);
    var type = externalCodePointerType(attrs.abi, attrs.variadic?, attrs.argumentTypes, attrs.returnType);
    return RTValue(RT_VALUE_RVALUE, type, x, x.name);
}

externalAttributes(ex:RTExternal) = ref maybe(ex.externalAttributes,
    a ref=> ref a,
    () ref=> ref initializeExternalAttributes(ex),
);

private validExternalArgumentType?(type)
    = symbolType?(typeSymbol(type)) and podType?(type);

private initializeExternalAttributes(ex:RTExternal) {
    var env = newEnv(ex.module);

    var attributeValues = maybe(ex.ast.externalAttributes,
        attributes ref=> evaluateExprList(attributes, env),
        () ref=> ValueList(),
    );

    var argumentTypes = ValueList(mapped(a ref=> externalArgumentType(a, env), ex.ast.arguments.items));
    // XXX handle noreturn externals
    var returnType = maybe(ex.ast.returns, extReturn ref=>
        maybe(extReturn.returnType, returnExpr ref=>
            withLocation(returnExpr, () ref=> {
                var returnType = evaluateExpr(returnExpr, env);
                if (not validExternalArgumentType?(returnType))
                    genericError("external functions may only return values of POD types");
                return Maybe(returnType);
            }),
        ),
    );

    var symbolName = ex.name;
    var abi = getHooks().CdeclABI;
    var variadic? = ex.ast.arguments.variadic?;

    maybe(ex.ast.externalAttributes, attributes ref=> {
        withLocation(ex.ast, () ref=> {
            applyExternalAttributes(attributeValues, symbolName, abi);

            if (not abiSupportsVariadics?(abi) and variadic?)
                genericError("external function with ", abi, " does not support variadic arguments");
        });
    });

    ex.externalAttributes = Maybe(RTExternalAttributes(
        symbolName,
        abi,
        variadic?,
        argumentTypes,
        returnType
    ));

    return ref just(ex.externalAttributes);
}

private applyExternalAttributes(attributeValues, outSymbolName, outAbi) {
    var gotName? = false;
    var gotAbi?  = false;

    for (value in attributeValues)
        match(value,
            StringValue, sv ref=> {
                if (gotName?)
                    genericError("multiple external symbol names specified for external function");
                gotName? = true;
                outSymbolName = sv.value; 
            },
            MatchDefault, x ref=> {
                if (abiValue?(value)) {
                    if (gotAbi?)
                        genericError("multiple ABIs specified for external function");
                    gotAbi? = true;
                    outAbi = value;
                }
            },
        );
}

private externalArgumentType(arg:ast.ExternalArgument, env)
    = withLocation(arg, () ref=> {
        var argType = evaluateExpr(arg.type, env);
        if (not validExternalArgumentType?(argType))
            genericError("external functions may only take values of POD types as arguments");
        return argType;
    });



//
// globalRTValue, globalRTValueList, globalAttributes
//

private analyzeGlobal(g:RTGlobal) {
    ref globalMap = getProgram().globalMap;

    assert(null?(lookup(globalMap.constructors, g)), "unprotected recursive global reference");
    var binding = variantAs(g.head.ast, GlobalBinding);
    return withGlobalAnalysis(g, () ref=>
        withLocation(binding.ast, () ref=> {
            push(globalMap.globalOrder, g);
            var type = analyzeGlobal2(g, binding);
            return RTGlobalAttributes(type);
        })
    );
}

private analyzeGlobal2(g:RTGlobal, binding:GlobalBinding) {
    ref globalMap = getProgram().globalMap;
    var complete? = true;
    var returns = SpecializationReturns();
    var constructorS = SpecializationContext(&globalMap.constructors[g], &complete?, &returns);

    return maybe(binding.ast.value,
        valueExpr ref=> {
            var resultTypes = analyzeSubnode(constructorS, g.env, valueExpr);
            assert(complete?, "unresolvable recursion in global initializer");
            assert(not returns.results?, "global initializer shouldn't return");

            return maybe(resultTypes,
                results ref=> {
                    if (size(results) != 1)
                        genericError("single-value global binding gave ", size(results), " results");

                    var type = results[0].type;

                    maybe(binding.ast.type, declaredTypeExpr ref=> {
                        withLocation(declaredTypeExpr, () ref=> {
                            var declaredType = evaluateExpr(declaredTypeExpr, g.env);
                            if (declaredType != type)
                                genericError(
                                    "global variable declared with type ", declaredType,
                                    " but bound to value of type ", type,
                                );
                        });
                    });

                    addSpecializedInitialize(constructorS, valueExpr, results[0], _globalRTValue(g, type));
                    return type;
                },
                () ref=> {
                    genericError("global initializer is nonreturning");
                    return Value();
                },
            );
        },
        () ref=> maybe(binding.ast.type,
            declaredTypeExpr ref=> evaluateExpr(declaredTypeExpr, g.env),
            () ref=> {
                genericError("global variable binding must have a declared type or an initializer expression");
                return Value();
            },
        ),
    );
}

globalAttributes(g:RTGlobal) = safeInitialize(g.attributes, () ref=> analyzeGlobal(g));
globalBinding(g:RTGlobal) = variantAs(g.head.ast, GlobalBinding);
globalKind(g:RTGlobal) {
    switch (globalBinding(g).kind) {
    case ast.BINDING_RVALUE:
        genericError("global variables cannot be rvalues");
        return RTValueKind();
    case ast.BINDING_FORWARD:
        genericError("global variables cannot be forward");
        return RTValueKind();
    case ast.BINDING_REF:
        genericError("global ref bindings not yet supported");
        return RTValueKind();
    case ast.BINDING_CONST:
        genericError("global const bindings not yet supported");
        return RTValueKind();
    default:
        return RT_VALUE_REF;
    }
}

private _globalRTValue(g:RTGlobal, type:Value)
    = RTValue(globalKind(g), type, g);

globalRTValue(g:RTGlobal) = _globalRTValue(g, globalAttributes(g).type);



//
// analyzeMain
//

analyzeMain() {
    var mainValue = envEntryToValue(publicLookup(getProgramMainModule(), "main"));
    return analyzeCallable(mainValue, RTValues());
}


//
// analyzeLiteralCodeBody
//

private analyzeLiteralCodeBody(s:SpecializationContext, env:Env, body:ast.LiteralCodeBody) {
    return addSpecializedLiteralCodeBody(s, env, body);
}


//
// analyzeNode
//

analyzeNode(s:SpecializationContext, env:Env, body:ast.ExprCodeBody)
    = analyzeSubnode(s, newEnv(env), body.exprs);


//
// analyzeNode(ReturnExprList; ReturnExprListItem instances)
//

analyzeExprListNode(s, env, exprList) {
    var outputs = RTValues();
    for (item in exprList) {
        var itemOutputs = withLocation(item,
            () ref=> analyzeExprListItem(s, env, item, size(outputs))
        );
        if (nothing?(itemOutputs))
            return nothing(RTValues);
        push(outputs, just(itemOutputs));
    }
    return Maybe(outputs);
}

analyzeMultiExprListNode(s, env, exprList, multi?) {
    if (multi? and size(exprList) == 1 and variantIs?(exprList[0], ast.Expr))
        return analyzeMultiExprSubnode(s, env, *exprList[0]);
    return analyzeExprListNode(s, env, exprList);
}

overload analyzeNode(s:SpecializationContext, env:Env, exprList:ast.ReturnExprList)
    Maybe[RTValues]
{
    var results = analyzeExprListNode(s, env, exprList);
    maybe(results, r ref=> {
        if (s.returns^.results?) {
            if (size(s.returns^.results) != size(r))
                genericError("number of return values does not match previous return");
        } else
            s.returns^.results? = true;
    });
    return move(results);
}

private procedure analyzeExprListItem;
overload analyzeExprListItem(
    s:SpecializationContext,
    env:Env,
    rItem:ast.ReturnExprListItem,
    position:SizeT
)
    Maybe[RTValues]
{
    var results = withLocation(rItem.item,
        () ref=> analyzeExprListItem(s, env, rItem.item, position)
    );
    return maybe(results,
        rs ref=> Maybe(map(
            (i, r) ref=> analyzeReturn(s, rItem, r, position + i),
            enumerated(rs)
        )), 
    );
}

private bindReferenceReturn(s, rItem, kind, source, position) {
    if (s.returns^.results?) {
        if (position >= size(s.returns^.results))
            genericError("number of return values does not match previous return");
        ref result = s.returns^.results[position];
        ref namedResult = s.returns^.namedResults[position];
        if (result.type != source.type)
            genericError("return type ", source.type, " does not match previous return type ", result.type);
        if (not referenceVariable?(result))
            genericError("return by reference does not match previous return by value");
        if (result.kind != kind)
            genericError("return reference kind does not match previous return reference kind");
        assert(
            referenceVariable?(namedResult)
            and namedResult.kind == RT_VALUE_REF
            and pointerType?(namedResult.type)
            and pointerTargetType(namedResult.type) == result.type,
            "named return must match external return"
        );
        addSpecializedAddressOf(s, rItem, source, namedResult);
        return result;
    } else {
        assert(
            size(s.returns^.results) == position
            and size(s.returns^.namedResults) == position,
            "result list out of sync"
        );
        var result = RTValue(kind, source.type, ReferenceVariable(), "returned");
        push(s.returns^.results, result);
        var namedResult = newReference(RT_VALUE_REF, pointerType(source.type), "returned");
        addSpecializedAddressOf(s, rItem, source, namedResult);
        push(s.returns^.namedResults, namedResult);
        return result;
    }
}

private bindValueReturn(s, rItem, source, position) {
    if (s.returns^.results?) {
        if (position >= size(s.returns^.results))
            genericError("number of return values does not match previous return");
        ref result = s.returns^.results[position];
        ref namedResult = s.returns^.namedResults[position];
        if (result.type != source.type)
            genericError("return type ", source.type, " does not match previous return type ", result.type);
        if (not localVariable?(result))
            genericError("return by value does not match previous return by reference");
        assert(
            referenceVariable?(namedResult)
            and namedResult.kind == RT_VALUE_REF
            and namedResult.type == result.type,
            "named return must match external return"
        );
        addSpecializedInitialize(s, rItem, source, namedResult);
        return result;
    } else {
        assert(
            size(s.returns^.results) == position
            and size(s.returns^.namedResults) == position,
            "result list out of sync"
        );
        var result = RTValue(RT_VALUE_RVALUE, source.type, LocalVariable(), "returned");
        push(s.returns^.results, result);
        var namedResult = newReference(RT_VALUE_REF, source.type, "returned");
        addSpecializedInitialize(s, rItem, source, namedResult);
        push(s.returns^.namedResults, namedResult);
        return result;
    }
}

private analyzeReturn(
    s:SpecializationContext,
    rItem:ast.ReturnExprListItem,
    source:RTValue,
    position:SizeT
) = maybe(rItem.kind,
    // reference return
    returnKind ref=> {
        switch (returnKind) {
        case ast.RETURN_EXPR_CONST:
            if (localVariable?(source))
                genericError("cannot return temporary as const reference");
            if (source.kind == RT_VALUE_RVALUE)
                genericError("cannot return rvalue as const reference");
            if (source.kind != RT_VALUE_CONST)
                return bindReferenceReturn(s, rItem, RT_VALUE_CONST, source, position);
            break;
        case ast.RETURN_EXPR_REF:
            if (localVariable?(source))
                genericError("cannot return temporary as ref reference");
            if (source.kind == RT_VALUE_RVALUE)
                genericError("cannot return rvalue as ref reference");
            if (source.kind == RT_VALUE_CONST)
                genericError("cannot return const as ref reference");
            break;
        case ast.RETURN_EXPR_RVALUE:
            if (localVariable?(source))
                genericError("cannot return temporary as rvalue reference");
            if (source.kind == RT_VALUE_CONST)
                genericError("cannot return const as rvalue reference");
            if (source.kind != RT_VALUE_RVALUE)
                return bindReferenceReturn(s, rItem, RT_VALUE_RVALUE, source, position);
            break;
        case ast.RETURN_EXPR_FORWARD:
            if (localVariable?(source) or source.kind == RT_VALUE_RVALUE) {
                if (source.kind != RT_VALUE_RVALUE)
                    genericError("cannot forward non-rvalue temporary value");
                return bindValueReturn(s, rItem, source, position);
            }
            break;
        default:
            assert(false, "invalid reference kind");
            return RTValue();
        }
        return bindReferenceReturn(s, rItem, source.kind, source, position);
    },
    // value return
    () ref=> bindValueReturn(s, rItem, source, position),
);


//
// analyzeNode(ExprList; ExprListItem instances)
//

overload analyzeNode(s:SpecializationContext, env:Env, exprList:ast.ExprList) Maybe[RTValues]
    = analyzeExprListNode(s, env, exprList);

overload analyzeExprListItem(
    s:SpecializationContext,
    env:Env,
    expr:ast.ExprListItem,
    pos:SizeT
) Maybe[RTValues] = analyzeNode(s, env, *expr);

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.Expr) Maybe[RTValues]
    = analyzeNode(s, env, *expr);

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.SubExprList) Maybe[RTValues]
    = analyzeNode(s, env, expr.exprList);

overload analyzeNode(s:SpecializationContext, env:Env, unpack:ast.UnpackExpr)
    = analyzeMultiExprSubnode(s, env, unpack.expr);

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.StatementExprList) {
    return analyzeStatementExprListNode(s, newEnv(env), expr);
}



//
// analyzeNode(Expr instances)
//

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.BoolLiteral)
    = addSpecializedValue(s, expr, Value(BoolValue(expr.value)));

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.IntLiteral)
    = addSpecializedValue(s, expr, Value(parseIntLiteral(expr.negative?, expr.value)));

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.StringLiteral)
    = addSpecializedValue(s, expr, Value(StringValue(parseStringLiteral(expr.value))));

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.CharLiteral)
    = addSpecializedValue(s, expr, Value(CharValue(UInt32(parseCharLiteral(expr.value)))));

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.FloatLiteral)
    = addSpecializedValue(s, expr, Value(parseFloatLiteral(expr.negative?, expr.value)));

private analyzeEnvEntry(s, expr, envEntry) = match(envEntry,
    RTValue, x ref=> Maybe(RTValues(x)),
    Value, x ref=> addSpecializedValue(s, expr, x),
    Alias, x ref=> addSpecializedValue(s, expr, aliasValue(x)),
    ValueList, x ref=>
        genericAnalysisError("multiple values cannot be used in single value context"),
    PatternCell, x ref=>
        genericAnalysisError("pattern variable cannot be used in non-pattern expression"),
    ListPatternCell, x ref=>
        genericAnalysisError("pattern variable cannot be used in non-pattern expression"),
    RTValueList, x ref=>
        genericAnalysisError("multiple values cannot be used in single value context"),
    RTLabel, x ref=>
        genericAnalysisError("label cannot be used as a value"),
    RTExternal,   x ref=> Maybe(RTValues(addRvalue(s, externalRTValue(x)))),
    RTGlobal,     x ref=> Maybe(RTValues(globalRTValue(x))),
);

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.NameRef) {
    var envEntry = nameRefLookup(env, expr);
    return analyzeEnvEntry(s, expr, envEntry);
}

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.SimpleNameRef) {
    var envEntry = privateLookup(env, expr.name);
    return analyzeEnvEntry(s, expr, envEntry);
}

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.PatternNameRef)
    = addSpecializedValue(s, expr, derefPattern(env, expr.name));

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.TupleExpr) {
    return maybe(analyzeExprListNode(s, env, expr.args),
        args ref=> analyzeCallWithOneResult(s, expr, getHooks().tupleLiteral, args)
    );
}

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.Call)
    = withOneResult(analyzeCallNode(s, env, expr));

private analyzeStatementExprNode2(s, bc:BlockContext, statements, expr, subnodeFn) {
    var pc = ProcContext(nothing(ir.BreakTargetId));
    var lc = LoopContext();

    for (stmt in statements)
        if (statementNoReturn?(analyzeStatement(s, pc, bc, lc, stmt)))
            // return nothing;
            return ...mapValues(call, ...Type(...subnodeFn(s, bc.env, expr)));

    return ...subnodeFn(s, bc.env, expr);
}

overload analyzeStatementExprNode2(s, env:Env, statements, expr, subnodeFn) {
    var bc = BlockContext(env);
    return ...analyzeStatementExprNode2(s, bc, statements, expr, subnodeFn);
}

private analyzeStatementExprNode(s, env, expr)
    = analyzeStatementExprNode2(s, env, expr.statements, expr.expr, analyzeSubnode);
private analyzeMultiStatementExprNode(s, env, expr)
    = analyzeStatementExprNode2(s, env, expr.statements, expr.expr, analyzeMultiExprSubnode);
private analyzeStatementExprListNode(s, env, expr)
    = analyzeStatementExprNode2(s, env, expr.statements, expr.exprList, analyzeNode);

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.StatementExpr) {
    return analyzeStatementExprNode(s, newEnv(env), expr);
}

analyzeCallWithOneResult(s:SpecializationContext, ast, callable:Value, args:RTValues) {
    return withOneResult(analyzeCall(s, ast, callable, args));
}

unifyCodePointerArgumentType(argType:Value, arg:RTValue) {
    var expected = refTypeToRTArgument(argType);
    return expected.type == arg.type
        and (expected.kind == RT_VALUE_CONST or expected.kind == arg.kind);
}

private typeToExternalRTArgument(arg) {
    if (not validExternalArgumentType?(arg))
        matchFailureError("external code pointers must have only by-value POD types as input types");
    return refTypeToRTArgument(arg);
}

analyzeRTPrimitive(s, ast, primitive:RTPrimitive, args:RTValues) {
    switch (primitive.kind) {
    case RTPRIM_makeCodePointer: {
        if (size(args) < 1)
            matchFailureError("makeCodePointer requires at least one argument");
        var callable = staticTypeValue(args[0].type);
        var inputTypes = ValueList(
            mapped(x => staticTypeValue(x.type), slicedFrom(args, 1))
        );
        var callArgs = map(refTypeToRTArgument, inputTypes);

        var specialization = analyzeCallable(callable, callArgs);

        var outputTypes = ValueList(
            mapped(rtReturnToRefType, just(specialization.results, RTValues()))
        );
        var resultType = codePointerType(inputTypes, outputTypes);
        var result = RTValue(RT_VALUE_RVALUE, resultType, LocalVariable());
        addSpecializedNode(s, ir.AddressOfCode(ir.ASTNode(ast), specialization, result));
        return Maybe(RTValues(result));
    }

    case RTPRIM_makeExternalCodePointer: {
        if (size(args) < 2)
            matchFailureError("makeExternalCodePointer requires at least two arguments");
        var callable = staticTypeValue(args[0].type);
        var abi = staticTypeValue(args[1].type);

        if (not abiValue?(abi))
            matchFailureError("makeExternalCodePointer requires an ABI symbol as its second argument");

        var inputTypes = ValueList(
            mapped(x => staticTypeValue(x.type), slicedFrom(args, 2))
        );

        var callArgs = map(typeToExternalRTArgument, inputTypes);

        var specialization = analyzeCallable(callable, callArgs);

        var outputs = just(specialization.results, RTValues());
        var nOutputs = size(outputs);
        if (nOutputs > 1)
            matchFailureError("makeExternalCodePointer target must return zero or one POD values");

        var outputType = nothing(Value);
        if (nOutputs == 1) {
            if (not podType?(outputs[0].type))
                matchFailureError("makeExternalCodePointer target must return a POD value");
            outputType = Maybe(outputs[0].type);
        }

        var resultType = externalCodePointerType(abi, false, inputTypes, outputType);
        var result = RTValue(RT_VALUE_RVALUE, resultType, LocalVariable());
        addSpecializedNode(s, ir.AddressOfExternalCode(ir.ASTNode(ast), specialization, result));
        return Maybe(RTValues(result));
    }

    case RTPRIM_callCodePointer: {
        if (size(args) < 1)
            matchFailureError("callCodePointer requires at least one argument");
        var cp = args[0];
        var inputs = sliceFrom(args, 1);

        if (not codePointerType?(cp.type))
            matchFailureError("first argument to callCodePointer must be a CodePointer");

        var inputTypes = codePointerInputTypes(cp.type);
        if (size(inputTypes) != size(inputs))
            matchFailureError("expected ", size(inputTypes), " arguments for code pointer, but got ", size(inputs));

        for (inputType, input in zipped(inputTypes, inputs))
            if (not unifyCodePointerArgumentType(inputType, input))
                matchFailureError(
                    "argument types do not match code pointer's input types\n",
                    "  expected types: ", ArgumentList(map(refTypeToRTArgument, inputTypes)), "\n",
                    "  got types:      ", ArgumentList(inputs),
                );
        var outputs = map(
            refTypeToRTReturn,
            codePointerOutputTypes(cp.type)
        );

        addSpecializedNode(s, ir.DereferenceCall(
            ir.ASTNode(ast),
            cp,
            inputs,
            Maybe(outputVariables(outputs)),
        ));
        return Maybe(outputs);
    }

    default: {
        assert(false, "invalid runtime primitive");
        return nothing(RTValues);
    }

    }
}

analyzeCall(s:SpecializationContext, ast, callable:Value, args:RTValues)
    = match(callable,
        RTPrimitive, p ref=> analyzeRTPrimitive(s, ast, p, args),
        MatchDefault, x ref=> addSpecializedCall(s, ast, args, analyzeCallable(callable, args)),
    );

private ifStaticValue(s, env, expr, thenFn, elseFn)
    = ...maybe(analyzeSubnode(s, env, expr),
        results ref=> {
            var result = singleValue(results);
            if (staticType?(result.type))
                return ...thenFn(staticTypeValue(result.type));
            return ...elseFn(result);
        },
    );

private withOneResult(mResults) {
    maybe(mResults, results ref=> {
        ensureArity(1, size(results));
    });
    return mResults;
}

private analyzeIndexing(s:SpecializationContext, env:Env, expr:ast.Indexing) {
    return ifStaticValue(s, env, expr.expr,
        staticIndexee ref=> analyzeEnvEntry(s, expr,
            evaluateIndexingEntry(staticIndexee, evaluateExprList(expr.args, env))
        ),
        indexee ref=> maybe(analyzeExprListNode(s, env, expr.args), indexArgs ref=> {
            var operands = RTValues(indexee);
            push(operands, indexArgs);
            return analyzeCall(s, expr, getHooks().index, operands);
        }),
    );
}

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.Indexing)
    = withOneResult(analyzeIndexing(s, env, expr));

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.StaticIndexing) {
    return ifStaticValue(s, env, expr.expr,
        staticIndexee ref=> analyzeEnvEntry(s, expr,
            evaluateIndexingEntry(staticIndexee, ValueList(parseIntLiteral(false, expr.index.value)))
        ),
        indexee ref=> {
            var indexValue = Value(parseIntLiteral(false, expr.index.value));
            var indexArg = singleAddSpecializedStaticValue(s, expr.index, indexValue);
            var operands = RTValues(indexee, indexArg);
            return analyzeCall(s, expr, getHooks().staticIndex, operands);
        }
    );
}

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.FieldRef) {
    return ifStaticValue(s, env, expr.expr,
        staticIndexee ref=> addSpecializedValue(s, expr,
            evaluateFieldRef(staticIndexee, Value(StringValue(expr.field.str)))
        ),
        indexee ref=> {
            var fieldValue = Value(StringValue(expr.field.str));
            var fieldArg = singleAddSpecializedStaticValue(s, expr, fieldValue);
            var operands = RTValues(indexee, fieldArg);
            return analyzeCall(s, expr, getHooks().fieldRef, operands);
        }
    );
}

private analyzeShortCircuit(s, env, expr, leftValue, LeftBody, RightBody)
    = maybe(analyzeBoolSubnode(s, env, expr.expr1),
        leftResults ref=> {
            var leftResult = singleValue(leftResults);
            var output = RTValue(RT_VALUE_RVALUE, boolType(), LocalVariable());

            var ifNode = ir.If(ir.ASTNode(expr), leftResult,
                Vector[ir.Node](),
                Vector[ir.Node]()
            );

            var leftS = subContext(s, fieldRef(ifNode, LeftBody));
            addSpecializedBind(leftS, ir.ASTNode(expr),
                addImmediate(leftS, boolType(), leftValue),
                output
            );

            var rightS = subContext(s, fieldRef(ifNode, RightBody));
            maybe(analyzeBoolSubnode(rightS, env, expr.expr2),
                results2 ref=> {
                    addSpecializedBind(rightS, ir.ASTNode(expr),
                        singleValue(results2),
                        output
                    );
                },
            );

            useBranchRvalues(s, leftS, rightS);
            addRvalue(s, output);
            addSpecializedNode(s, ifNode);

            return Maybe(RTValues(output));
        },
    );

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.AndExpr)
    = analyzeShortCircuit(s, env, expr, Value(BoolValue(false)), #elseBody, #thenBody);

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.OrExpr)
    = analyzeShortCircuit(s, env, expr, Value(BoolValue(true)), #thenBody, #elseBody);

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.NotExpr)
    = maybe(analyzeBoolSubnode(s, env, expr.expr), input ref=> {
        var output = newRvalue(boolType());
        addSpecializedNot(s, expr, singleValue(input), output);
        return Maybe(RTValues(output));
    });

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.LambdaExpr)
    = analyzeLambda(s, env, expr);

private analyzeThrowExprNode(s, env, expr) {
    try {
        maybe(analyzeSubnode(s, env, expr.value), exResult ref=> {
            addSpecializedThrow(s, expr, singleValue(exResult));
        });
    } catch (e:RecursiveAnalysisError) {
        s.complete?^ = false;
    }
    return nothing(RTValues);
}

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.ThrowExpr)
    = analyzeThrowExprNode(s, env, expr);

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.IfExpr) {
    var bc = BlockContext(newEnv(env));
    return maybe(analyzeBoolStatementExprNode(s, bc, expr.condition),
        condResult ref=> {
            var ifNode = ir.If(ir.ASTNode(expr), singleValue(condResult),
                Vector[ir.Node](),
                Vector[ir.Node]()
            );
            addSpecializedNode(s, ifNode);

            var thenRecursive? = false;
            var elseRecursive? = false;
            var thenResult = nothing(RTValues);
            var elseResult = nothing(RTValues);

            var thenS = subContext(s, ifNode.thenBody);
            var elseS = subContext(s, ifNode.elseBody);

            try {
                thenResult = analyzeSubnode(thenS, bc.env, expr.thenPart);
            } catch (e:RecursiveAnalysisError) {
                s.complete?^ = false;
                thenRecursive? = true;
            }

            try {
                elseResult = analyzeSubnode(elseS, bc.env, expr.elsePart);
            } catch (e:RecursiveAnalysisError) {
                s.complete?^ = false;
                elseRecursive? = true;
            }

            if (thenRecursive? and elseRecursive?)
                recursiveAnalysisError();

            useBranchRvalues(s, thenS, elseS);
            var outputs = unifyIfExprBranches(s, expr, ifNode, thenResult, elseResult, thenS, elseS);
            return outputs;
        },
    );
}

private unifyIfExprReferent(thenv, elsev) {
    if (thenv.kind == RT_VALUE_RVALUE and elsev.kind == RT_VALUE_RVALUE
        and localVariable?(thenv) and localVariable?(elsev))

        return RTValueReferent(LocalVariable());
    else
        return RTValueReferent(ReferenceVariable());
}

private unifyIfExprBranches(s, expr, ifNode, thenResult, elseResult, thenS, elseS)
    = maybe(thenResult,
        thenr ref=> maybe(elseResult,
            elser ref=> {
                var thenv = singleValue(thenr);
                var elsev = singleValue(elser);
                if (thenv.type != elsev.type)
                    genericError("return types in if expression branches do not match");
                var output = RTValue();

                if (thenv.kind == elsev.kind)
                    output = RTValue(thenv.kind, thenv.type,
                        unifyIfExprReferent(thenv, elsev),
                    );
                else
                    output = RTValue(RT_VALUE_RVALUE, thenv.type, LocalVariable());

                addSpecializedBind(thenS, expr, thenv, output);
                addSpecializedBind(elseS, expr, elsev, output);
                addRvalue(s, output);

                return Maybe(RTValues(output));
            },
            () ref=> addRvalue(s, thenResult),
        ),
        () ref=> addRvalue(s, elseResult),
    );

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.PairExpr)
    = maybe(analyzeSubnode(s, env, expr.expr),
        rightResults ref=> {
            var rightResult = singleValue(rightResults);
            var leftResult = singleAddSpecializedStaticValue(s, expr, Value(StringValue(expr.name.str)));
            var operands = RTValues(leftResult, rightResult);
            return analyzeCallWithOneResult(s, expr, getHooks().tupleLiteral, operands);
        },
    );

private analyzeUnaryOp(s, env, expr)
    = maybe(analyzeSubnode(s, env, expr.expr), operands ref=> {
        var operatorCallable = Value();
        switch (expr.operator) {
        case ast.OP_ADDRESS_OF: {
            var operand = singleValue(operands);
            if (operand.kind == RT_VALUE_RVALUE)
                genericError("cannot take the address of an rvalue");
            var output = newRvalue(pointerType(operand.type));
            addSpecializedAddressOf(s, expr, operand, output);
            return Maybe(RTValues(output));
        }
        case ast.OP_PLUS:
            operatorCallable = getHooks().plus;
            break;
        case ast.OP_MINUS:
            operatorCallable = getHooks().minus;
            break;
        case ast.OP_UNPACK:
            operatorCallable = getHooks().unpack;
            break;
        case ast.OP_DEREFERENCE:
            operatorCallable = getHooks().dereference;
            break;
        default:
            assert(false, "invalid unary operator");
            break;
        }
        return analyzeCall(s, expr, operatorCallable, operands);
    });

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.UnaryOpExpr)
    = withOneResult(analyzeUnaryOp(s, env, expr));

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.BinaryOpExpr)
    = maybe(analyzeSubnode(s, env, expr.expr1), operands1 ref=>
        maybe(analyzeSubnode(s, env, expr.expr2), operands2 ref=> {
            var operands = RTValues(singleValue(operands1), singleValue(operands2));
            var operatorCallable = Value();

            switch (expr.operator) {
            case ast.OP_MULTIPLY:
                operatorCallable = getHooks().multiply;
                break;
            case ast.OP_DIVIDE:
                operatorCallable = getHooks().divide;
                break;
            case ast.OP_QUOTIENT:
                operatorCallable = getHooks().quotient;
                break;
            case ast.OP_REMAINDER:
                operatorCallable = getHooks().remainder;
                break;
            case ast.OP_ADD:
                operatorCallable = getHooks().add;
                break;
            case ast.OP_SUBTRACT:
                operatorCallable = getHooks().subtract;
                break;
            case ast.OP_LESSER?:
                operatorCallable = getHooks().lesser?;
                break;
            case ast.OP_LESSER_EQUALS?:
                operatorCallable = getHooks().lesserEquals?;
                break;
            case ast.OP_GREATER?:
                operatorCallable = getHooks().greater?;
                break;
            case ast.OP_GREATER_EQUALS?:
                operatorCallable = getHooks().greaterEquals?;
                break;
            case ast.OP_EQUALS?:
                operatorCallable = getHooks().equals?;
                break;
            case ast.OP_NOT_EQUALS?:
                operatorCallable = getHooks().notEquals?;
                break;
            default:
                assert(false, "invalid binary operator");
                break;
            }
            return analyzeCallWithOneResult(s, expr, operatorCallable, operands);
        })
    );

overload analyzeNode(s:SpecializationContext, env:Env, expr:ast.StaticExpr) {
    var value = evaluateExpr(expr.expr, env);
    return addSpecializedStaticValue(s, expr, value);
}


//
// analyzeBlockCodeBody, analyzeStatement
//

private record ProcContext (
    currentTargetId: Maybe[ir.BreakTargetId],
    recursiveReturn: Maybe[ast.ReturnStatement],
);

overload ProcContext()
    = ProcContext(Maybe(ir.BreakTargetId(0)), Maybe[ast.ReturnStatement]());
overload ProcContext(targetId)
    = ProcContext(targetId, Maybe[ast.ReturnStatement]());

private returnTargetId(pc) = ir.BreakTargetId(0);

private nextTargetId(pc) {
    return maybe(pc.currentTargetId,
        currentTargetId ref=> {
            var id = currentTargetId;
            inc(currentTargetId);
            return id;
        },
        () ref=> {
            genericError("blocks not allowed in statement expression");
            return ir.BreakTargetId();
        },
    );
}

private record BlockContext (
    env: Env,
);

private record LoopContext (
    breakTarget: Maybe[ir.BreakTargetId],
    continueTarget: Maybe[ir.BreakTargetId],
    infiniteLoop?: Bool,
);

overload LoopContext() = LoopContext(nothing(ir.BreakTargetId), nothing(ir.BreakTargetId), false);
overload LoopContext(b:ir.BreakTargetId, c:ir.BreakTargetId, i?:Bool)
    = LoopContext(Maybe(b), Maybe(c), i?);
overload LoopContext(loop:ir.While, infinite?:Bool) {
    var target = loop.label;
    return LoopContext(target, target, infinite?);
}
overload LoopContext(breakBlock:ir.Block, continueBlock:ir.Block) {
    return LoopContext(breakBlock.label, continueBlock.label, false);
}

private record StatementReturn ();
private record StatementNoReturn ();

private variant StatementTarget = Nothing            // statement proceeds to next normally
                                | ir.BreakTargetId   // statement breaks/continues to target
                                | StatementReturn
                                | StatementNoReturn; // statement is nonterminating

overload StatementTarget() = StatementTarget(Nothing());
[F | F == ir.Block or F == ir.While]
overload StatementTarget(frame:F) = StatementTarget(frame.label);
overload StatementTarget(static StatementReturn) = StatementTarget(StatementReturn());
overload StatementTarget(static StatementNoReturn) = StatementTarget(StatementNoReturn());

statementBreaks?(tgt:StatementTarget) = not variantIs?(tgt, Nothing);
statementBreaksAt?(tgt:StatementTarget, frame) = match(tgt,
    ir.BreakTargetId, bt ref=> bt == frame.label,
    MatchDefault, x ref=> false,
);
statementReturns?(tgt:StatementTarget) = variantIs?(tgt, StatementReturn);
statementNoReturn?(tgt:StatementTarget) = variantIs?(tgt, StatementNoReturn);

resultTarget(results:Maybe[RTValues]) = maybe(results,
    r => StatementTarget(),
    () => StatementTarget(StatementNoReturn),
);

private analyzeBlockCodeBody(s:SpecializationContext, env:Env, block:ast.Block)
    = withLocation(block, () ref=> {
        var pc = ProcContext();
        var bc = BlockContext(env);
        var lc = LoopContext();

        var target = analyzeStatement(s, pc, bc, lc, block);

        if (statementBreaks?(target)) {
            assert(statementReturns?(target) or statementNoReturn?(target),
                "procedure body cannot escape procedure"
            );
            // "returns" without results? => nonterminating result
            // "returns" without definite results, but recursive return? => recursion error
            // returns with results? => results
            if (s.returns^.results?) {
                return Maybe(s.returns^.results);
            } else {
                maybe(pc.recursiveReturn, stmt ref=> {
                    withLocation(stmt, () ref=> {
                        recursiveAnalysisError();
                    });
                });
                return nothing(RTValues);
            }
        } else {
            // falls through with no results? => void results
            // falls through with nonvoid results? => error (not all branches return)
            // falls through with void results? => void results
            if (s.returns^.results? and not empty?(s.returns^.results))
                genericError("not all branches return in block");
            return Maybe(RTValues());
        }
    });

[T] private stmtMaybe(value:Maybe[T], thenFn) = maybe(value,
    thenFn,
    () => StatementTarget(StatementNoReturn)
);

private analyzeStatement(
    s:SpecializationContext,
    pc:ProcContext,
    bc:BlockContext,
    lc:LoopContext,
    stmt:ast.Statement
) StatementTarget = withLocation(stmt, () ref=> analyzeStatement(s, pc, bc, lc, *stmt));

private envAddLabel(env:Env, mLabel:Maybe[ast.LabelDef], ...targets) {
    maybe(mLabel, label ref=> {
        envAdd(env, label.name, RTLabel(label, ...mapValues(x => x.label, ...targets)));
    });
}

overload analyzeStatement(s, pc, bc, lc, block:ast.Block) StatementTarget {
    var blockNode = ir.Block(nextTargetId(pc));
    var blockS = subContext(s, blockNode.body);
    var subbc = BlockContext(newEnv(bc.env));
    envAddLabel(subbc.env, block.label, blockNode);
    var target = StatementTarget();
    for (stmt in block.statements) {
        var statementNode = allocateRef(ir.Statement);
        var statementS = subContext(blockS, statementNode.body);
        target = analyzeStatement(statementS, pc, subbc, lc, stmt);
        useSubRvalues(blockS, statementS);
        addSpecializedNode(blockS, statementNode);
        if (statementBreaks?(target))
            break;
    }

    useSubRvalues(s, blockS);
    addSpecializedNode(s, blockNode);
    if (statementBreaksAt?(target, blockNode))
        return StatementTarget();
    else
        return target;
}

private withInitializeValues(s, env, stmt, fn)
    = stmtMaybe(analyzeNode(s, env, stmt.to),
        toValues ref=> stmtMaybe(analyzeMultiExprListNode(s, env, stmt.from, size(toValues) != 1),
            fromValues ref=> fn(toValues, fromValues),
        ),
    );

private analyzeInitialize(s, env:Env, stmt) {
    try {
        return withInitializeValues(s, env, stmt, (toValues, fromValues) ref=> {
            if (size(toValues) != size(fromValues))
                matchFailureError("got ", size(toValues), " values on left side of <-- but ", size(fromValues), " values on right side");
            for (toValue, fromValue in zipped(toValues, fromValues)) {
                if (toValue.kind != RT_VALUE_REF)
                    matchFailureError("values on left side of <-- expression must be non-const lvalues");
                if (toValue.type != fromValue.type)
                    matchFailureError(
                        "type mismatch in <-- expression\n",
                        "  left side:  ", map(x => x.type, toValues),   "\n",
                        "  right side: ", map(x => x.type, fromValues),
                    );
                addSpecializedInitialize(s, stmt, fromValue, toValue);
            }
            return StatementTarget();
        });
    } catch (e:RecursiveAnalysisError) {
    // XXX recursive analysis will need to be an error if it influences delayed propagation of var
    // bindings
        s.complete?^ = false;
        return StatementTarget();
    }
}

private singleExpr(s, env, exprList:ast.ExprList) {
    if (size(exprList) != 1)
        return nothing(ast.Expr);
    return match(exprList[0],
        ast.UnpackExpr, x => nothing(ast.Expr),
        ast.Expr, x => Maybe(x),
        ast.StatementExprList, x =>
            analyzeStatementExprNode2(s, env, x.statements, x.exprList, singleExpr),
        ast.SubExprList, x => singleExpr(s, env, x.exprList),
    );
}

private singleExpr?(exprList:ast.ExprList) {
    if (size(exprList) != 1)
        return false;
    return match(exprList[0],
        ast.UnpackExpr, x => false,
        ast.Expr, x => true,
        ast.StatementExprList, x => singleExpr?(x.exprList),
        ast.SubExprList, x => singleExpr?(x.exprList),
    );
}

private procedure assignCallOp;
overload assignCallOp(s, env, expr)
    = nothing(Value), analyzeSubnode(s, env, expr);
overload assignCallOp(s, env, expr:ast.Indexing) {
    return ...ifStaticValue(s, env, expr.expr,
        staticIndexee ref=> {
            return nothing(Value), analyzeEnvEntry(s, expr,
                evaluateIndexingEntry(staticIndexee, evaluateExprList(expr.args, env))
            );
        },
        indexee ref=> {
            return ...maybe(analyzeExprListNode(s, env, expr.args), indexArgs ref=> {
                var operands = RTValues(indexee);
                push(operands, indexArgs);
                return Maybe(getHooks().index), Maybe(operands);
            });
        },
    );
}
overload assignCallOp(s, env, expr:ast.StaticIndexing) {
    return ...ifStaticValue(s, env, expr.expr,
        staticIndexee ref=> {
            return nothing(Value), analyzeEnvEntry(s, expr,
                evaluateIndexingEntry(staticIndexee, ValueList(parseIntLiteral(false, expr.index.value)))
            );
        },
        indexee ref=> {
            var indexValue = Value(parseIntLiteral(false, expr.index.value));
            var indexArg = singleAddSpecializedStaticValue(s, expr.index, indexValue);
            var operands = RTValues(indexee, indexArg);
            return Maybe(getHooks().staticIndex), Maybe(operands);
        }
    );
}
overload assignCallOp(s, env, expr:ast.FieldRef) {
    return ...ifStaticValue(s, env, expr.expr,
        staticIndexee ref=> {
            return nothing(Value), addSpecializedValue(s, expr,
                evaluateFieldRef(staticIndexee, Value(StringValue(expr.field.str)))
            );
        },
        indexee ref=> {
            var fieldValue = Value(StringValue(expr.field.str));
            var fieldArg = singleAddSpecializedStaticValue(s, expr, fieldValue);
            var operands = RTValues(indexee, fieldArg);
            return Maybe(getHooks().fieldRef), Maybe(operands);
        }
    );
}
overload assignCallOp(s, env, expr:ast.UnaryOpExpr) {
    switch (expr.operator) {
    case ast.OP_UNPACK:
        return Maybe(getHooks().unpack), analyzeSubnode(s, env, expr.expr);
    case ast.OP_DEREFERENCE:
        return Maybe(getHooks().dereference), analyzeSubnode(s, env, expr.expr);
    default:
        return nothing(Value), analyzeSubnode(s, env, expr);
    }
}
//XXX overload assignCallOp(s, env, expr:ast.StatementExpr) {
// analyze statements, recursively analyze final expression

private analyzeAssign(s, env, stmt) {
    if (not singleExpr?(stmt.to))
        genericError("multiple assignment not yet supported");

    return maybe(singleExpr(s, env, stmt.to),
        toExpr ref=> {
            var updateOp = nothing(Value);

            switch (stmt.kind) {
            case ast.ASSIGNMENT_ASSIGN:
                updateOp = nothing(Value);
                break;
            case ast.ASSIGNMENT_ADD:
                updateOp = Maybe(getHooks().add);
                break;
            case ast.ASSIGNMENT_SUBTRACT:
                updateOp = Maybe(getHooks().subtract);
                break;
            case ast.ASSIGNMENT_MULTIPLY:
                updateOp = Maybe(getHooks().multiply);
                break;
            case ast.ASSIGNMENT_DIVIDE:
                updateOp = Maybe(getHooks().divide);
                break;
            case ast.ASSIGNMENT_QUOTIENT:
                updateOp = Maybe(getHooks().quotient);
                break;
            case ast.ASSIGNMENT_REMAINDER:
                updateOp = Maybe(getHooks().remainder);
                break;
            default:
                assert(false, "invalid assignment operator");
                break;
            }

            var callOp, callArgs = ...assignCallOp(s, env, *toExpr);
            return maybe(callArgs,
                toArgs ref=> maybe(analyzeExprListNode(s, env, stmt.from),
                    fromValues ref=> {
                        if (size(fromValues) != 1)
                            genericError("got one value on left side of assignment, but ", size(fromValues), " values on right side");
                        var fromValue = fromValues[0];
                        var callable, args = ...maybe(updateOp,
                            updatee ref=> ...maybe(callOp,
                                callee ref=> {
                                    //updateCallAssign(#updateOp, fromValue, #callOp, ..callArgs)
                                    var args = RTValues();
                                    push(args, singleAddSpecializedStaticValue(s, stmt, updatee));
                                    push(args, fromValue);
                                    push(args, singleAddSpecializedStaticValue(s, toExpr, callee));
                                    push(args, toArgs);
                                    return getHooks().updateCallAssign, args;
                                },
                                () ref=> {
                                    //updateAssign(#updateOp, toValue, fromValue)
                                    var args = RTValues();
                                    push(args, singleAddSpecializedStaticValue(s, stmt, updatee));
                                    assert(size(toArgs) == 1, "more than one single assignment value");
                                    push(args, toArgs[0]);
                                    push(args, fromValue);
                                    return getHooks().updateAssign, args;
                                },
                            ),
                            () ref=> ...maybe(callOp,
                                callee ref=> {
                                    //callAssign(fromValue, #callOp, ..callArgs)
                                    var args = RTValues();
                                    push(args, fromValue);
                                    push(args, singleAddSpecializedStaticValue(s, toExpr, callee));
                                    push(args, toArgs);
                                    return getHooks().callAssign, args;
                                },
                                () ref=> {
                                    //assign(toValue, fromValue)
                                    var args = RTValues();
                                    assert(size(toArgs) == 1, "more than one single assignment value");
                                    push(args, toArgs[0]);
                                    push(args, fromValue);
                                    return getHooks().assign, args;
                                },
                            ),
                        );
                        return resultTarget(analyzeCall(s, stmt, callable, args));
                    },
                    () ref=> StatementTarget(StatementNoReturn),
                ),
                () ref=> StatementTarget(StatementNoReturn),
            );
        },
        () ref=> {
            genericError("multiple-value assignment not yet supported");
            return StatementTarget();
        },
    );
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.AssignmentStatement) {
    switch (stmt.kind) {
    case ast.ASSIGNMENT_INITIALIZE:
        return analyzeInitialize(s, bc.env, stmt);
    default:
        return analyzeAssign(s, bc.env, stmt);
    }
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.BindingStatement) {
    var subenv, target = ...analyzeBindings(s, bc.env, stmt, stmt.kind, stmt.bindings);
    bc.env = subenv;
    return target;
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.ReturnStatement) {
    if (nothing?(pc.currentTargetId))
        genericError("return cannot be used in a statement expression");

    try {
        maybe(analyzeNode(s, bc.env, stmt.values),
            results ref=> {
                addSpecializedNode(s, ir.Break(stmt, returnTargetId(pc)));
            },
        );
    } catch (e:RecursiveAnalysisError) {
        s.complete?^ = false;
        pc.recursiveReturn = Maybe(stmt);
    }
    return StatementTarget(StatementReturn);
}

private envEntryToLabel(stmtName, entry) = match(entry,
    RTLabel, label ref=> label,
    MatchDefault, x ref=> {
        genericError(StaticName(stmtName), " target must be a label");
        return RTLabel();
    }
);

private breakTarget(
    stmtName,
    pc:ProcContext,
    bc:BlockContext,
    lc:LoopContext,
    labelName:Maybe[ast.Identifier]
) {
    if (nothing?(pc.currentTargetId))
        genericError(StaticName(stmtName), " statement cannot be used in a statement expression");
    return maybe(labelName,
        label ref=> fieldRef(
            envEntryToLabel(stmtName, privateLookup(bc.env, label)),
            IdentifierConcat(stmtName, #"Target"),
        ),
        () ref=> maybe(fieldRef(lc, IdentifierConcat(stmtName, #"Target")),
            target ref=> target,
            () ref=> {
                genericError(StaticName(stmtName), " statement cannot be used outside of a loop without a label");
                return ir.BreakTargetId();
            }
        ),
    );
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.BreakStatement) {
    var target = breakTarget(#"break", pc, bc, lc, stmt.label);
    //XXX clear infiniteLoop? at While analysis level: lc.infiniteLoop? = false;
    addSpecializedNode(s, ir.Break(stmt, target));
    return StatementTarget(target);
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.ContinueStatement) {
    var target = breakTarget(#"continue", pc, bc, lc, stmt.label);
    addSpecializedNode(s, ir.Continue(stmt, target));
    return StatementTarget(target);
}

private branchStatementTarget(thenTarget, elseTarget) {
    if (not statementBreaks?(thenTarget) or not statementBreaks?(elseTarget))
        return StatementTarget();
    if (thenTarget == elseTarget)
        return thenTarget;
    if (statementNoReturn?(thenTarget))
        return elseTarget;
    if (statementNoReturn?(elseTarget))
        return thenTarget;
    return StatementTarget(max(
        variantAs(thenTarget, ir.BreakTargetId),
        variantAs(elseTarget, ir.BreakTargetId),
    ));
}

private analyzeBranch(s, ast, cond, else?, thenAnalysisFn, elseAnalysisFn) {
    var ifNode = ir.If(ir.ASTNode(ast), cond,
        Vector[ir.Node](),
        Vector[ir.Node](),
    );

    var thenRecursive? = false;
    var elseRecursive? = not else?;
    var thenTarget = StatementTarget();
    var elseTarget = StatementTarget();
    var thenS = subContext(s, ifNode.thenBody);
    var elseS = subContext(s, ifNode.elseBody);

    try {
        thenTarget = thenAnalysisFn(thenS);
    } catch (e:RecursiveAnalysisError) {
        thenRecursive? = true;
    }

    if (else?)
        try {
            elseTarget = elseAnalysisFn(elseS);
        } catch (e:RecursiveAnalysisError) {
            elseRecursive? = true;
        }

    if (thenRecursive? and elseRecursive?)
        recursiveAnalysisError();

    if (statementBreaks?(thenTarget) and statementBreaks?(elseTarget)) {
        //nothing
    } else if (statementBreaks?(thenTarget))
        useSubRvalues(s, elseS);
    else if (statementBreaks?(elseTarget))
        useSubRvalues(s, thenS);
    else
        useBranchRvalues(s, thenS, elseS);

    addSpecializedNode(s, ifNode);
    return branchStatementTarget(thenTarget, elseTarget);
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.IfStatement) {
    var bc2 = BlockContext(newEnv(bc.env));
    return stmtMaybe(analyzeBoolStatementExprNode(s, bc2, stmt.condition), condResult ref=> {
        return analyzeBranch(
            s, stmt, singleValue(condResult), just?(stmt.elseBody),
            thenS ref=> analyzeStatement(
                thenS,
                pc,
                BlockContext(newEnv(bc2.env)),
                lc,
                stmt.thenBody
            ),
            elseS ref=> analyzeStatement(
                elseS,
                pc,
                BlockContext(newEnv(bc2.env)),
                lc,
                just(stmt.elseBody)
            ),
        );
    });
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.StaticForStatement) {
    var blockNode = ir.Block(nextTargetId(pc));
    var blockS = subContext(s, blockNode.body);
    addSpecializedNode(s, blockNode);

    for (valueItem in stmt.values) {
        var target = stmtMaybe(analyzeExprListItem(blockS, bc.env, valueItem, SizeT(0)), forValues ref=> {
            for (value in forValues) {
                var subNode = ir.Block(nextTargetId(pc));
                var subS = subContext(blockS, subNode.body);
                addSpecializedNode(blockS, subNode);

                var forEnv = newEnv(bc.env);
                envAddLabel(forEnv, stmt.label, blockNode, subNode);
                addForBinding(subS, forEnv, stmt, *stmt.bodyBinding, value);

                var bodyTarget = analyzeStatement(
                    subS,
                    pc,
                    BlockContext(forEnv),
                    LoopContext(blockNode, subNode),
                    stmt.body
                );

                if (statementBreaks?(bodyTarget) and not statementBreaksAt?(bodyTarget, subNode))
                    return bodyTarget;
            }
            return StatementTarget();
        });
        if (statementBreaks?(target)) {
            if(statementBreaksAt?(target, blockNode))
                return StatementTarget();
            return target;
        }
    }
    return StatementTarget();
}

private trueCondition?(condBody)
    // XXX check for true condition
    = false;

private analyzeLoop(s, ast, pc, bc, condAnalysisFn, bodyAnalysisFn) {
    var whileNode = ir.While(
        nextTargetId(pc),
        ir.ASTNode(ast),
        Vector[ir.Node](),
        RTValue(),
        Vector[ir.Node](),
    );
    var loopS = loopSubContext(s, whileNode.conditionBody);
    return maybe(condAnalysisFn(loopS),
        condResult ref=> {
            whileNode.condition = singleValue(condResult);
            useRvalue(loopS, whileNode.condition);

            var subbc = BlockContext(newEnv(bc.env));
            var sublc = LoopContext(whileNode, trueCondition?(whileNode.conditionBody));

            envAddLabel(subbc.env, ast.label, whileNode);

            var bodyTarget = bodyAnalysisFn(loopSubContext(s, whileNode.body), subbc, sublc);

            addSpecializedNode(s, whileNode);
            if (sublc.infiniteLoop?)
                return StatementTarget(StatementNoReturn);
            return StatementTarget();
        },
        () ref=> {
            addSpecializedNodes(s, whileNode.conditionBody);
            return StatementTarget(StatementNoReturn);
        }
    );
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.WhileStatement) {
    var bc2 = BlockContext(newEnv(bc.env));
    return analyzeLoop(s, stmt, pc, bc2,
        condS ref=> analyzeBoolStatementExprNode(condS, bc2, stmt.condition),
        (bodyS, subbc, sublc) ref=> analyzeStatement(bodyS, pc, subbc, sublc, stmt.body),
    );
}

private analyzeForBindings(s, env, stmt:ast.ForStatement, bindingValues:RTValues) {
    if (not arityMatches?(stmt.bodyBindings, bindingValues))
        // XXX improve error messages
        genericError("incorrect number of iterator values in for loop");
    for (arg, value in zipped(stmt.bodyBindings.items, bindingValues))
        addForBinding(s, env, stmt, *arg, value);
    maybe(stmt.bodyBindings.variadicItem, varArg ref=> {
        addVariadicForBinding(s, env, stmt, *varArg, sliceFrom(bindingValues, size(stmt.bodyBindings.items)));
    });
}

capturedForValue(s, stmt, formalKind, value)
    = if (value.kind == RT_VALUE_RVALUE and not inValues?(formalKind, ast.ARG_RVALUE, ast.ARG_FORWARD))
        addCapture(s, stmt, value)
    else
        value;

private bindForBinding(env, arg:ast.BoundArgument, value) {
    envAdd(env, arg.name, value);
}
overload bindForBinding(env, arg:ast.StaticArgument, value:RTValue) {
    initializePatternVars(env, collectPatternVars(arg));
    unify(evaluatePattern(arg.pattern, env), staticTypeValue(value.type));
}
overload bindForBinding(env, arg:ast.StaticArgument, values:RTValueList) {
    initializePatternVars(env, collectPatternVars(arg));
    unifyList(
        ListPattern(Vector[Pattern](), evaluateListPatternCell(arg.pattern, env)),
        ValueList(mapped(x => staticTypeValue(x.type), values.vars))
    );
}

private addForBinding(s, env, stmt, arg:ast.BoundArgument, value) {
    withLocation(arg, () ref=> {
        var formalKind = referenceSpecifier(arg);
        var value2 = capturedForValue(s, stmt, formalKind, value);
        if (not referenceKindMatches?(formalKind, value2.kind))
            // XXX improve error messages
            matchFailureError("incorrect reference kind for iterator value in for loop");
        if (not unifyArgumentType(arg, value2, env))
            // XXX improve error messages
            genericError("mismatched type for iterator value in for loop: ", value.type);
        var loweredKind = loweredArgumentKind(formalKind, value2.kind);
        var loweredValue = newReference(loweredKind, value2.type, argumentNameString(arg));
        addSpecializedBind(s, stmt, value2, loweredValue);

        envAdd(env, arg.name, loweredValue);
    });
}
overload addForBinding(s, env, stmt, arg:ast.StaticArgument, value) {
    withLocation(arg, () ref=> {
        initializePatternVars(env, collectPatternVars(arg));
        unify(evaluatePattern(arg.pattern, env), staticTypeValue(value.type));
    });
}

private addVariadicForBinding(s, env, stmt, varArg:ast.BoundArgument, values) {
    withLocation(varArg, () ref=> {
        var formalKind = referenceSpecifier(varArg);
        var values2 = map(v ref=> {
            var v2 = capturedForValue(s, stmt, formalKind, v);
            if (not referenceKindMatches?(formalKind, v2.kind))
                // XXX improve error messages
                genericError("incorrect reference kinds for variadic iterator value in for loop: ");
            var loweredKind = loweredArgumentKind(formalKind, v2.kind);
            var loweredValue = newReference(loweredKind, v2.type, argumentNameString(varArg));
            addSpecializedBind(s, stmt, v2, loweredValue);
            return v2;
        }, values);
        if (not unifyVariadicArgumentType(varArg, values2, env))
            genericError("mismatched types for variadic iterator value in for loop: ",
                ValueList(mapped(v => v.type, values2))
            );

        var listVar = RTValueList(values2);
        envAdd(env, varArg.name, listVar);
    });
}
overload addVariadicForBinding(s, env, stmt, varArg:ast.StaticArgument, values) {
    withLocation(varArg, () ref=> {
        initializePatternVars(env, collectMultiPatternVars(varArg));
        unifyList(
            ListPattern(Vector[Pattern](), evaluateListPatternCell(varArg.pattern, env)),
            ValueList(mapped(x => staticTypeValue(x.type), values))
        );
    });
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.ForStatement)
    = stmtMaybe(analyzeSubnode(s, bc.env, stmt.sequenceValue), seqValues ref=> {
        var seqValue = addCapture(s, stmt, singleValue(seqValues));

        return stmtMaybe(
            withLocation(stmt.sequenceValue, () ref=>
                analyzeCallWithOneResult(s, stmt.sequenceValue, getHooks().iterator, RTValues(seqValue)),
            ),
            iterResults ref=> {
                var iterResult = singleValue(iterResults);
                var iterValue = RTValue(RT_VALUE_REF, iterResult.type, LocalVariable());
                addSpecializedBind(s, stmt, iterResult, iterValue);

                return analyzeLoop(s, stmt, pc, bc,
                    condS ref=> withLocation(stmt.sequenceValue, () ref=> withBoolResult(
                        analyzeCallWithOneResult(condS, stmt.sequenceValue, getHooks().hasFront?, RTValues(iterValue))
                    )),
                    (bodyS, subbc, sublc) ref=> stmtMaybe(
                        withLocation(stmt, () ref=> analyzeCall(bodyS, stmt, getHooks().front, RTValues(iterValue))),
                        bindingValues ref=> {
                            analyzeForBindings(bodyS, subbc.env, stmt, bindingValues);

                            var continueBlockNode = ir.Block(nextTargetId(pc));
                            var continueBlockS = subContext(bodyS, continueBlockNode.body);
                            var continuebc = BlockContext(newEnv(subbc.env));
                            var continuelc = LoopContext(
                                sublc.breakTarget,
                                Maybe(continueBlockNode.label),
                                false
                            );

                            var target = analyzeStatement(continueBlockS,
                                pc, continuebc, continuelc, stmt.body
                            );

                            useSubRvalues(bodyS, continueBlockS);
                            addSpecializedNode(bodyS, continueBlockNode);
                            if (not statementBreaksAt?(target, continueBlockNode)
                                and statementBreaks?(target))
                                return target;

                            return stmtMaybe(
                                withLocation(stmt, () ref=> analyzeCall(bodyS, stmt, getHooks().incFront, RTValues(iterValue))),
                                v ref=> StatementTarget(),
                            );
                        },
                    ),
                );
            }
        );
    });

private analyzeCase(s, pc, bc, lc, testValue, stmt:ast.SwitchStatement, caseI:SizeT) {
    ref caseBlock = stmt.caseBlocks[caseI];
    return stmtMaybe(analyzeExprListNode(s, bc.env, caseBlock.values), caseValues ref=> {
        var caseArgs = RTValues(testValue);
        push(caseArgs, caseValues);
        var mCaseResult = withBoolResult(withLocation(caseBlock, () ref=>
            analyzeCallWithOneResult(s, caseBlock, getHooks().case?, caseArgs)
        ));

        var nextCase? = caseI + 1 < size(stmt.caseBlocks);
        var default? = just?(stmt.defaultBlock);

        return stmtMaybe(mCaseResult, caseResults ref=> {
            return analyzeBranch(
                s, caseBlock.body, singleValue(caseResults), nextCase? or default?,
                caseS ref=> analyzeStatement(
                    caseS,
                    pc,
                    BlockContext(newEnv(bc.env)),
                    lc,
                    caseBlock.body
                ),
                nextCaseS ref=> if (nextCase?)
                        analyzeCase(nextCaseS, pc, bc, lc, testValue, stmt, caseI + 1)
                    else
                        analyzeStatement(
                            nextCaseS, pc, BlockContext(newEnv(bc.env)), lc,
                            just(stmt.defaultBlock)
                        ),
            );
        });
    });
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.SwitchStatement) {
    var bc2 = BlockContext(newEnv(bc.env));
    return stmtMaybe(analyzeStatementExprNode(s, bc2, stmt.value), testValues ref=> {
        assert(size(stmt.caseBlocks) > 0, "switch must have at least one case block");
        return analyzeCase(s, pc, bc2, lc,
            addCapture(s, stmt, singleValue(testValues)),
            stmt, SizeT(0)
        );
    });
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.TryStatement) {
    // XXX true exception support
    return analyzeStatement(s, pc, bc, lc, stmt.body);
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.ExprStatement) StatementTarget {
    try {
        return stmtMaybe(analyzeMultiExprSubnode(s, bc.env, stmt.expr), results ref=> {
            for (result in results)
                addSpecializedNode(s, ir.Consume(result));
            return StatementTarget();
        });
    } catch (e:RecursiveAnalysisError) {
        s.complete?^ = false;
        return StatementTarget();
    }
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.EmptyStatement) StatementTarget {
    return StatementTarget();
}

overload analyzeStatement(s, pc, bc, lc, stmt:ast.UnreachableStatement) StatementTarget {
    return StatementTarget(StatementNoReturn);
}


//
// analyzeBindings
//

private analyzeBindings(
    s:SpecializationContext,
    env:Env,
    stmt:ast.BindingStatement,
    kind:ast.BindingKind,
    bindingList
) {
    return ...analyzeStrictBindings(s, env, stmt, kind, *bindingList);
}

private procedure analyzeStrictBindings;

overload analyzeStrictBindings(
    s:SpecializationContext,
    env_:Env,
    stmt:ast.BindingStatement,
    kind:ast.BindingKind,
    bindingList:ast.SingleBindingList
) {
    var env = env_;
    for (binding in bindingList) {
        env = newEnv(env);
        var target = maybeAnalyzeSingleBinding(s, env, stmt, kind, binding);
        if (statementBreaks?(target))
            return env, target;
    }
    return env, StatementTarget();
}

private maybeAnalyzeSingleBinding(s, env, stmt, kind, binding)
    = stmtMaybe(analyzeSubnode(s, env, binding.value), valueResult ref=> {
        analyzeSingleBinding(s, env, stmt, kind, binding.name, singleValue(valueResult));
        return StatementTarget();
    });

private localVariableBinding?(bindingKind, value)
    = bindingKind == ast.BINDING_VAR
      or (bindingKind == ast.BINDING_CONST and value.kind == RT_VALUE_RVALUE)
      or (inValues?(bindingKind, ast.BINDING_FORWARD, ast.BINDING_RVALUE)
          and value.kind == RT_VALUE_RVALUE
          and not referenceVariable?(value));

private analyzeBindingVar(s, stmt, kind, name, value) {
    var variableKind = bindingVariableKind(kind, value.kind);
    var variableReferent = if (localVariableBinding?(kind, value))
            RTValueReferent(LocalVariable())
        else
            RTValueReferent(ReferenceVariable());
    var result = RTValue(variableKind, value.type, variableReferent, name);
    addSpecializedBind(s, stmt, value, result);
    return result;
}

private analyzeSingleBinding(
    s,
    env,
    stmt:ast.BindingStatement,
    kind:ast.BindingKind,
    bindingName:ast.BindingName,
    value:RTValue
) {
    maybe(bindingName.type, typeExpr ref=> {
        var bindingType = evaluateExpr(typeExpr, env);
        if (bindingType != value.type)
            genericError(
                "variable declared with type ", bindingType,
                " but bound to value of type ", value.type,
            );
    });

    envAdd(env, bindingName.name, analyzeBindingVar(s, stmt, kind, bindingName.name.str, value));
}

private bindingVariableKind(bindingKind:ast.BindingKind, valueKind:RTValueKind) {
    switch (bindingKind) {
    case ast.BINDING_VAR:
        return RT_VALUE_REF;
    case ast.BINDING_REF:
        if (valueKind != RT_VALUE_REF)
            matchFailureError("ref must be bound to a non-const lvalue");
        return RT_VALUE_REF;
    case ast.BINDING_RVALUE:
        if (valueKind != RT_VALUE_RVALUE)
            matchFailureError("rvalue reference must be bound to an rvalue");
        return RT_VALUE_RVALUE;
    case ast.BINDING_CONST:
        return RT_VALUE_CONST;
    case ast.BINDING_FORWARD:
        return valueKind;
    default:
        assert(false, "invalid binding kind");
        return RTValueKind();
    }
}

overload analyzeStrictBindings(
    s:SpecializationContext,
    env_:Env,
    stmt:ast.BindingStatement,
    kind:ast.BindingKind,
    bindingList:ast.MultipleBindingList
) {
    var env = newEnv(env_);
    return ...maybe(bindingList.values,
        valueExprList ref=> ...maybe(analyzeMultiExprListNode(s, env, valueExprList, true),
            values ref=> {
                if (not arityMatches?(bindingList.names, values))
                    // XXX better error message
                    genericError("incorrect number of values for variable binding");
                for (binding, value in zipped(bindingList.names.items, values))
                    analyzeSingleBinding(s, env, stmt, kind, binding, value);

                maybe(bindingList.names.variadicItem, varItem ref=> {
                    var variadicVars = map(
                        value ref=> analyzeBindingVar(s, stmt, kind, varItem.name.str, value),
                        slicedFrom(values, size(bindingList.names.items))
                    );

                    envAdd(env, varItem.name, RTValueList(variadicVars, varItem.name));
                });

                return env, StatementTarget();
            },
            () ref=> ...(env, StatementTarget(StatementNoReturn)),
        ),
        () ref=> {
            // XXX
            genericError("variable binding without initialization is not yet supported");
            return env, StatementTarget();
        },
    );
}


//
// analyzeMultiExprSubnode
//

private analyzeMultiExprSubnode(s, env, ast) Maybe[RTValues]
    = withLocation(ast, () ref=> analyzeMultiExprNode(s, env, ast));

private analyzeMultiExprNode(s, env, ast)
    = genericAnalysisError("single value cannot be used in multiple value context");

overload analyzeMultiExprNode(s, env, expr:ast.Expr) Maybe[RTValues] {
    return analyzeMultiExprSubnode(s, env, *expr);
}

private analyzeMultiEnvEntry(s, expr, envEntry) = match(envEntry,
    RTValueList, x ref=> Maybe(x.vars),
    Value, x ref=>
        genericAnalysisError("single value cannot be used in multiple value context"),
    Alias, x ref=>
        genericAnalysisError("single value cannot be used in multiple value context"),
    ValueList, x ref=> addSpecializedValueList(s, expr, x),
    PatternCell, x ref=>
        genericAnalysisError("pattern variable cannot be used in non-pattern expression"),
    ListPatternCell, x ref=>
        genericAnalysisError("pattern variable cannot be used in non-pattern expression"),
    RTValue, x ref=>
        genericAnalysisError("single value cannot be used in multiple value context"),
    RTLabel, x ref=>
        genericAnalysisError("label cannot be used as a value"),
    RTExternal, x ref=>
        genericAnalysisError("single value cannot be used in multiple value context"),
    RTGlobal,     x ref=>
        genericAnalysisError("single value cannot be used in multiple value context"),
);

overload analyzeMultiExprNode(s, env, expr:ast.NameRef) {
    var envEntry = nameRefLookup(env, expr);
    return analyzeMultiEnvEntry(s, expr, envEntry);
}

overload analyzeMultiExprNode(s, env, expr:ast.SimpleNameRef) {
    var envEntry = privateLookup(env, expr.name);
    return analyzeMultiEnvEntry(s, expr, envEntry);
}

overload analyzeMultiExprNode(s:SpecializationContext, env:Env, expr:ast.PatternNameRef)
    = addSpecializedValueList(s, expr, derefListPattern(env, expr.name));

overload analyzeMultiExprNode(s:SpecializationContext, env:Env, expr:ast.Call)
    = analyzeCallNode(s, env, expr);

private analyzeCallNode(s:SpecializationContext, env:Env, expr:ast.Call)
    = ifStaticValue(s, env, expr.expr,
        callable ref=> {
            return maybe(analyzeNode(s, env, expr.args),
                inputs ref=> analyzeCall(s, expr, callable, inputs),
            );
        },
        callableResult ref=> maybe(analyzeNode(s, env, expr.args), inputs ref=> {
            var operands = RTValues(callableResult);
            push(operands, inputs);
            return analyzeCall(s, expr, getHooks().call, operands);
        }),
    );

overload analyzeMultiExprNode(s:SpecializationContext, env:Env, expr:ast.Indexing)
    = analyzeIndexing(s, env, expr);

overload analyzeMultiExprNode(s:SpecializationContext, env:Env, expr:ast.StaticExpr) {
    var values = evaluateMultiExpr(expr.expr, env);
    return addSpecializedStaticValueList(s, expr, values);
}

overload analyzeMultiExprNode(s:SpecializationContext, env:Env, expr:ast.UnaryOpExpr)
    = analyzeUnaryOp(s, env, expr);

overload analyzeMultiExprNode(s:SpecializationContext, env:Env, expr:ast.ThrowExpr)
    = analyzeThrowExprNode(s, env, expr);

overload analyzeMultiExprNode(s:SpecializationContext, env:Env, expr:ast.StatementExpr)
    = analyzeMultiStatementExprNode(s, newEnv(env), expr);


//
// analyzeBoolSubnode
//

validBoolResult?(results:Maybe[RTValues])
    = maybe(results,
        r => singleValue(r).type == boolType(),
        () => true
    );

withBoolResult(x) {
    if (not validBoolResult?(x))
        // OK to assume results is not Nothing and has one element here
        genericError(boolType(), " expected but ", just(x)[0].type, " received");
    return x;
}

analyzeBoolSubnode(s, env, ast) = withLocation(ast, () ref=> {
    try {
        return withBoolResult(analyzeNode(s, env, ast));
    } catch (e:RecursiveAnalysisError) {
        s.complete?^ = false;
        return Maybe(RTValues(addRvalue(s, newRvalue(boolType()))));
    }
});

analyzeBoolStatementExprNode(s, env, ast) = withLocation(ast, () ref=> {
    try {
        return withBoolResult(analyzeStatementExprNode(s, env, ast));
    } catch (e:RecursiveAnalysisError) {
        s.complete?^ = false;
        return Maybe(RTValues(addRvalue(s, newRvalue(boolType()))));
    }
});


//
// analyzeNode helpers
//

singleValue(s:RTValues) {
    if (size(s) != 1)
        genericError("multiple values cannot be used in single value context");
    return s[0];
}

cloneVariable(v:RTValue, ...name) = RTValue(v.kind, v.type, v.referent, ...name);
cloneVariables(vs:RTValues, ...name) = map(v ref=> cloneVariable(v, ...name), vs);
overload cloneVariables(mvs:Maybe[RTValues])
    = maybe(mvs, vs => Maybe(cloneVariables(vs)));

analyzeSubnode(s:SpecializationContext, env:Env, ast) Maybe[RTValues]
    = withLocation(ast, () ref=> analyzeNode(s, env, ast));

genericAnalysisError(forward ...err) {
    genericError(...err);
    return nothing(RTValues);
}

newRvalue(type, ...name) = RTValue(RT_VALUE_RVALUE, type, LocalVariable(), ...name);
newImmediate(type, value, ...name) = RTValue(RT_VALUE_RVALUE, type, value, ...name);
newReference(kind, type, ...name) = RTValue(kind, type, ReferenceVariable(), ...name);

addImmediate(s, type, value, ...name) {
    var rv = RTValue(RT_VALUE_RVALUE, type, value, ...name);
    addRvalue(s, rv);
    return rv;
}

addCapture(s, stmt, value, ...name) {
    var capturedValue = RTValue(
        if (value.kind == RT_VALUE_RVALUE) RT_VALUE_CONST else value.kind,
        value.type,
        if (value.kind == RT_VALUE_RVALUE)
            RTValueReferent(LocalVariable())
        else
            RTValueReferent(ReferenceVariable()),
        ...name
    );
    addSpecializedBind(s, stmt, value, capturedValue);
    return capturedValue;
}

private procedure intValueType;
overload intValueType(v:StaticIntValue) = intType();
overload intValueType(v:StaticUIntValue) = uintType();
overload intValueType(v:UInt8)  = uint8Type();
overload intValueType(v:UInt16) = uint16Type();
overload intValueType(v:UInt32) = uint32Type();
overload intValueType(v:UInt64) = uint64Type();
overload intValueType(v:Int8)  = int8Type();
overload intValueType(v:Int16) = int16Type();
overload intValueType(v:Int32) = int32Type();
overload intValueType(v:Int64) = int64Type();

private procedure floatValueType;
overload floatValueType(v:Float32) = float32Type();
overload floatValueType(v:Float64) = float64Type();

addSpecializedNode(s:SpecializationContext, node:ir.Node) {
    for (input in ir.nodeInputs(node))
        useRvalue(s, input);
    for (output in ir.nodeOutputs(node))
        addRvalue(s, output);
    push(s.body^, node);
}

[T | VariantMember?(ir.Node, T)]
overload addSpecializedNode(s:SpecializationContext, node:T) {
    addSpecializedNode(s, ir.Node(node));
}

addSpecializedNodes(s:SpecializationContext, nodes:Vector[ir.Node]) {
    for (node in nodes)
        addSpecializedNode(s, node);
}

addSpecializedLiteralCodeBody(s:SpecializationContext, env:Env, body:ast.LiteralCodeBody) {
    addSpecializedNode(s, ir.LiteralCodeBody(body, body.kind, ir.parseLiteralCodeBody(env, body.code)));
    return Maybe(RTValues());
}

// XXX needs to handle potentially nonterminating tuple and lambda conversions
singleAddSpecializedValue(s:SpecializationContext, ast, value:Value) RTValue = match(value,
    BoolValue, x ref=> addImmediate(s, boolType(), value),
    CharValue, x ref=> addImmediate(s, charType(), value),
    IntValue, x ref=> addImmediate(s, intValueType(*x), value),
    FloatValue, x ref=> addImmediate(s, floatValueType(*x), value),
    StringValue, x ref=> addImmediate(s, stringConstantType(), value),
    TupleValue, x ref=> {
        var elements = map(e ref=> singleAddSpecializedValue(s, ast, e), x.elements);
        return maybe(analyzeCallWithOneResult(s, ast, getHooks().tupleLiteral, elements),
            v => v[0],
            () => {
                // XXX
                genericError("tuple conversion does not terminate");
                return RTValue();
            },
        );
    },
    StaticLambdaValue, x ref=> {
        return maybe(analyzeLambda(s, x.env, x.value),
            v => v[0],
            () => {
                // XXX
                genericError("lambda conversion does not terminate");
                return RTValue();
            },
        );
    },
    MatchDefault, x ref=> addImmediate(s, staticType(Value(x)), value),
);

addSpecializedValue(s, ast, value)
    = Maybe(RTValues(singleAddSpecializedValue(s, ast, value)));

singleAddSpecializedStaticValue(s:SpecializationContext, ast, value:Value) {
    return addImmediate(s, staticType(value), value);
}

addSpecializedStaticValue(s, ast, value)
    = Maybe(RTValues(singleAddSpecializedStaticValue(s, ast, value)));

addSpecializedStaticValueList(s, ast, values:ValueList) {
    var outputs = RTValues(mapped(v ref=> addImmediate(s, staticType(v), v), values));
    return Maybe(outputs);
}

addSpecializedValueList(s:SpecializationContext, ast, valueList:ValueList) {
    var outputs = Vector(mapped(o ref=> singleAddSpecializedValue(s, ast, o), valueList));
    return Maybe(outputs);
}

private outputVariables(values)
    = map(r ref=> ir.OutputVariable(r, not localVariable?(r)), values);

private addOutOfLineCall(s, ast, inputs, specialization) {
    var mResults = cloneVariables(specialization.results);
    var outputs = maybe(mResults,
        results ref=> Maybe(outputVariables(results))
    );
    addSpecializedNode(s, ir.Call(ir.ASTNode(ast), inputs, outputs, specialization));
    return mResults;
}

/*INLINE
private addInlineCall(s, ast, inputs, specialization) {
    for (input, arg in zipped(inputs, specialization.internalArgs))
        addSpecializedBind(s, ast, input, arg);
    for (result in specialization.internalNamedResults)
        addSpecializedBind(s, ast, newRvalue(result.type, result.name), result);

    ...
}
*/

addSpecializedCall(
    s:SpecializationContext,
    ast,
    inputs:RTValues,
    specialization:Specialization
) {
    /*INLINE
    if (specialization.inline?)
        return addInlineCall(s, ast, inputs, specialization);
    else
    */
        return addOutOfLineCall(s, ast, inputs, specialization);
}

private verifyInitializable(s, ast, input, output) {
    if (not podType?(input.type) and not localVariable?(input)) {
        analyzeCall(subContext(s, Vector[ir.Node]()), ast,
            getHooks().initializeFrom,
            RTValues(output, input)
        );
    }
}

private verifyDestroyable(s, ast, value) {
    if (not podType?(value.type)) {
        analyzeCall(subContext(s, Vector[ir.Node]()), ast,
            getHooks().destroy,
            RTValues(value)
        );
    }
}

addSpecializedBind(
    s:SpecializationContext,
    ast,
    input:RTValue,
    output:RTValue
) {
    if (not podType?(output.type)) {
        var refOutput = RTValue(RT_VALUE_REF, output.type, output.referent);
        verifyInitializable(s, ast, input, refOutput);
        if (localVariable?(output))
            verifyDestroyable(s, ast, refOutput);
    }
    addSpecializedNode(s, ir.Bind(ir.ASTNode(ast), input, output));
    return Maybe(RTValues(output));
}

addSpecializedAddressOf(
    s:SpecializationContext,
    ast,
    input:RTValue,
    output:RTValue
) {
    addSpecializedNode(s, ir.AddressOf(ir.ASTNode(ast), input, output));
    return Maybe(RTValues(output));
}

addSpecializedNot(
    s:SpecializationContext,
    ast,
    input:RTValue,
    output:RTValue
) {
    addSpecializedNode(s, ir.Not(ir.ASTNode(ast), input, output));
    return Maybe(RTValues(output));
}

addSpecializedThrow(
    s:SpecializationContext,
    ast,
    exception:RTValue
) {
    addSpecializedNode(s, ir.Throw(ast, exception));
    return nothing(RTValues);
}

addSpecializedInitialize(
    s:SpecializationContext,
    ast,
    input:RTValue,
    output:RTValue
) {
    verifyInitializable(s, ast, input, output);
    addSpecializedNode(s, ir.Initialize(ir.ASTNode(ast), input, output));
    return Maybe(RTValues(output));
}


//
// matchOverload
//

[Arg, S | Sequence?(S)]
arityMatches?(formalArgs:ast.VariadicList[Arg], args:S) {
    if (nothing?(formalArgs.variadicItem))
        return size(args) == size(formalArgs.items);
    else
        return size(args) >= size(formalArgs.items);
}

private referenceSpecifier(formalArg:ast.Argument) = referenceSpecifier(*formalArg);
overload referenceSpecifier(x:ast.BoundArgument) = just(x.kind, ast.ARG_CONST);
overload referenceSpecifier(x:ast.StaticArgument) = ast.ARG_CONST;

private referenceKindMatches?(formalKind:ast.ArgumentKind, kind:RTValueKind) {
    if (formalKind == ast.ARG_REF)
        return kind == RT_VALUE_REF;
    if (formalKind == ast.ARG_RVALUE)
        return kind == RT_VALUE_RVALUE;
    return true;
}

private loweredArgumentKind(formalKind:ast.ArgumentKind, kind:RTValueKind) {
    if (formalKind == ast.ARG_CONST)
        return RT_VALUE_CONST;
    return kind;
}

private unifyArgumentType(formalArg:ast.Argument, arg:RTValue, env)
    = unifyArgumentType(*formalArg, arg, env);
overload unifyArgumentType(x:ast.BoundArgument, arg, env)
    = maybe(x.type,
        type ref=> {
            var typePattern = evaluatePattern(type, env);
            return unify(typePattern, arg.type);
        },
        () => true,
    );
overload unifyArgumentType(x:ast.StaticArgument, arg, env) {
    if (not staticType?(arg.type))
        return false;

    var staticPattern = evaluatePattern(x.pattern, env);
    return unify(staticPattern, staticTypeValue(arg.type));
}

private unifyVariadicArgumentType(formalArg, args, env)
    = unifyVariadicArgumentType(*formalArg, args, env);
overload unifyVariadicArgumentType(x:ast.BoundArgument, args, env)
    = maybe(x.type,
        type => {
            var listCell = evaluateListPatternCell(type, env);
            return unifyList(listCell, mapped(a => ref a.type, args));
        },
        () => true,
    );
overload unifyVariadicArgumentType(x:ast.StaticArgument, args, env) {
    for(arg in args)
        if (not staticType?(arg.type))
            return false;

    var staticPattern = evaluateListPatternCell(x.pattern, env);
    var types = ValueList(mapped(arg => staticTypeValue(arg.type), args));
    return unifyList(staticPattern, types);
}

private argumentName(formalArg) = argumentName(*formalArg);
overload argumentName(x:ast.BoundArgument) = Maybe(x.name);
overload argumentName(x:ast.StaticArgument) = nothing(ast.Identifier);

private argumentNameString(formalArg) = argumentName(*formalArg);
overload argumentNameString(x:ast.BoundArgument) = Maybe(x.name.str);
overload argumentNameString(x:ast.StaticArgument) = nothing(String);

private unifyArgument(s:Specialization, formalArg:ast.Argument, arg:RTValue) {
    var formalKind = referenceSpecifier(formalArg);

    if (not referenceKindMatches?(formalKind, arg.kind))
        return false;
    if (not unifyArgumentType(formalArg, arg, s.env))
        return false;
    var loweredArgKind = loweredArgumentKind(formalKind, arg.kind);
    var argName = argumentName(formalArg);
    var v = RTValue(loweredArgKind, arg.type, ReferenceVariable(), maybe(argName, name ref=> Maybe(name.str)));
    maybe(argName, name ref=> { envAdd(s.env, name, v); });
    push(s.args, v);
    return true;
}

private unifyVariadicArgument(s:Specialization, formalArg:ast.Argument, args) {
    var formalKind = referenceSpecifier(formalArg);

    var vars = RTValues();
    var argName = argumentName(formalArg);
    var argNameStr = maybe(argName, name ref=> Maybe(name.str));
    for (arg in args) {
        if (not referenceKindMatches?(formalKind, arg.kind))
            return false;
        var loweredArgKind = loweredArgumentKind(formalKind, arg.kind);
        var v = RTValue(loweredArgKind, arg.type, ReferenceVariable(), argNameStr);
        push(vars, v);
        push(s.args, v);
    }
    if (not unifyVariadicArgumentType(formalArg, args, s.env))
        return false;

    var listVar = RTValueList(vars);
    maybe(argName, name ref=> { envAdd(s.env, name, listVar); });

    return true;
}

private unifyArguments(s:Specialization, formalArgs, args) {
    for (formalArg, arg in zipped(formalArgs.items, args)) {
        if (not unifyArgument(s, formalArg, arg))
            return false;
    }
    var restArgs = slicedFrom(args, size(formalArgs.items));
    return maybe(formalArgs.variadicItem,
        formalArg ref=> unifyVariadicArgument(s, formalArg, restArgs),
        () => true,
    );
}

private bindNamedSingleReturn(s:Specialization, name, returnSpec) {
    var type = evaluateExpr(returnSpec.type, s.env);
    if (just?(returnSpec.kind))
        type = pointerType(type);
    var v = RTValue(RT_VALUE_REF, type, ReferenceVariable(), name);
    push(s.internalNamedResults, v);
    envAdd(s.env, name, v);
}

private bindNamedMultiReturn(s:Specialization, name, returnSpec) {
    var types = evaluateMultiExpr(returnSpec.type, s.env);
    var ref? = just?(returnSpec.kind);

    var vars = map(
        type ref=> RTValue(RT_VALUE_REF, if (ref?) pointerType(type) else type),
        types
    );

    var v = RTValueList(vars, name);
    envAdd(s.env, name, v);

    push(s.internalNamedResults, move(vars));
}

private bindNamedReturn(s:Specialization, name, returnSpec) {
    switch (returnSpec.arityKind) {
    case ast.RETURN_SINGLE:
        bindNamedSingleReturn(s, name, returnSpec);
        break;
    case ast.RETURN_MULTI:
        bindNamedMultiReturn(s, name, returnSpec);
        break;
    default:
        assert(false);
        break;
    }
}

private bindNamedReturns(s:Specialization) {
    ref oast = s.matchedOverload.ast;
    match(oast.definition.returns,
        Vector[ast.NamedReturn], namedReturns ref=> {
            for (namedReturn in namedReturns)
                bindNamedReturn(s, namedReturn.name, namedReturn.spec);
        },
        MatchDefault, x ref=> {},
    );
}

inlineAttribute?(attributes) = any?(attributes, a => a.kind == ast.OVERLOAD_INLINE);
nothrowAttribute?(attributes) = any?(attributes, a => a.kind == ast.OVERLOAD_NOTHROW);
noreturnAttribute?(attributes) = any?(attributes, a => a.kind == ast.OVERLOAD_NORETURN);

matchOverload(o:Overload, callable:Value, args:RTValues) MatchResult[Specialization] {
    ref formalArgs = o.ast.definition.args;
    if (not arityMatches?(formalArgs, args))
        return MatchResult[Specialization](MatchFailedArgCount());
    var pvars = topLevelItemPatternVars(o);
    var s = Specialization(o, callable);
    if (inlineAttribute?(o.ast.definition.attributes))
        s.inline? = true;
    s.env = initializeMatch(o.env, pvars);
    var callablePattern = evaluatePattern(o.ast.target, s.env);
    if (not unify(callablePattern, callable))
        return MatchResult[Specialization](MatchFailedPattern());
    if (not unifyArguments(s, formalArgs, args))
        return MatchResult[Specialization](MatchFailedPattern());
    assert(size(s.args) == size(args));
    s.internalArgs = s.args;
    verifyPatternVars(pvars, s.env);
    if (not testPredicate(o.ast.definition.predicate, s.env))
        return MatchResult[Specialization](MatchFailedPredicate());
    bindNamedReturns(s);
    return MatchResult[Specialization](MatchSuccess(s));
}


//
// analyzeCallable helpers
//

private procedure callableOverloads;
overload callableOverloads(program, callable) = nothing(Vector[Overload]);
overload callableOverloads(program, callable:SymbolHead)
    = if (program.overloadsDistributed?)
        Maybe(callable.overloads)
    else
        Maybe(program.symbolOverloads);

overload callableOverloads(program, callable:Symbol)
    = if (program.overloadsDistributed?)
        Maybe(callable.head.overloads)
    else
        Maybe(program.symbolOverloads);

private lambdaOverload(l:RuntimeLambdaValue) {
    return maybe(l.lambdaOverload,
        o ref=> o,
        () ref=> {
            var o = Overload(transformLambdaToOverload(l.value), l.env);
            l.lambdaOverload = Maybe(o);
            return o;
        },
    );
}

overload callableOverloads(program, callable:RuntimeLambdaValue) {
    return Maybe(Vector[Overload](lambdaOverload(callable)));
}

ifOverload(program, callable, args, thenFn, elseFn) {
    var overloads = callableOverloads(program, *callable);
    if (just?(overloads)) {
        for (x in reversed(just(overloads))) {
            var result = withRuntimeMatch(x, callable, args,
                () ref=> matchOverload(x, callable, args)
            );
            if (matchSuccess?(result))
                return forward ...thenFn(matchResult(result));
        }
    }

    for (x in reversed(program.patternOverloads)) {
        var result = withRuntimeMatch(x, callable, args,
            () ref=> matchOverload(x, callable, args)
        );
        if (matchSuccess?(result))
            return forward ...thenFn(matchResult(result));
    }
    return forward ...elseFn();
}

private findOverload(program, callable, args)
    = ifOverload(program, callable, args, s => s, () ref=> {
        matchFailureError("no matching runtime overload");
        return Specialization();
    });

private returnSpecKind(returnSpec: ast.ReturnSpec) {
    return ...maybe(returnSpec.kind,
        k => {
            switch (k) {
            case ast.RETURN_CONST: return RT_VALUE_CONST, RTValueReferent(ReferenceVariable());
            case ast.RETURN_REF: return RT_VALUE_REF, RTValueReferent(ReferenceVariable());
            case ast.RETURN_RVALUE: return RT_VALUE_RVALUE, RTValueReferent(ReferenceVariable());
            default :
                assert(false);
                return RTValueKind(), RTValueReferent(ReferenceVariable());
            }
        },
        () => ...(RT_VALUE_RVALUE, RTValueReferent(LocalVariable())),
    );
}

private computeReturnSpec(returns:Vector[ast.ReturnSpec], env) {
    // XXX handle noreturn syntax here
    var results = RTValues();
    for (returnSpec in returns) {
        if (returnSpec.arityKind == ast.RETURN_SINGLE) {
            var kind, referent = ...returnSpecKind(returnSpec);
            var type = evaluateExpr(returnSpec.type, env);
            push(results, RTValue(kind, type, referent));
        }
        else {
            assert(returnSpec.arityKind == ast.RETURN_MULTI);
            var kind, referent = ...returnSpecKind(returnSpec);
            var types = evaluateMultiExpr(returnSpec.type, env);
            for (type in types)
                push(results, RTValue(kind, type, referent));
        }
    }
    return move(results);
}

private computeNamedReturnSpec(returns:Vector[ast.NamedReturn], env)
    = computeReturnSpec(map(x => x.spec, returns), env);

private asNamedReturnVariable(result) = RTValue(
    RT_VALUE_REF,
    if (localVariable?(result)) result.type else pointerType(result.type),
    ReferenceVariable(),
    "returned"
);

analyzeCodeBody(s, env, codeBody)
    = match(codeBody,
        ast.ExprCodeBody, body ref=> analyzeNode(s, env, body.exprs),
        ast.LiteralCodeBody, body ref=> analyzeLiteralCodeBody(s, env, body),
        ast.Block, body ref=> analyzeBlockCodeBody(s, env, body),
        ast.UndefinedCodeBody, body ref=> {
            matchFailureError("undefined overload");
            return nothing(RTValues);
        },
    );


private bodyAnalyzedResults(s, env, definition) {
    var declaredNoReturn? = noreturnAttribute?(definition.attributes);

    var results = analyzeCodeBody(s, env, definition.body);
    if (declaredNoReturn? and variantIs?(definition.body, ast.LiteralCodeBody))
        return nothing(RTValues);

    if(just?(results) and declaredNoReturn?)
        genericError("procedure declared as noreturn but the body returns");

    return move(results);
}

private saveAnalyzedResults(s, returns, analyzedResults) {
    s.results = analyzedResults;
    if (nothing?(analyzedResults)) {
        // if function is nonterminating, promote any remaining return values
        // to local variables so they will absorb and destroy return values
        for (result in returns.namedResults)
            result.referent = RTValueReferent(LocalVariable());
        s.internalNamedResults = RTValues();
    } else
        s.internalNamedResults = returns.namedResults;
}

private procedure analyzeCallableDeclaredReturns;
overload analyzeCallableDeclaredReturns(s, env, o, namedReturns:Nothing) {
    var complete? = true;
    var returns = SpecializationReturns();
    var context = SpecializationContext(&just(s.body), &complete?, &returns);
    for (arg in s.internalArgs)
        addRvalue(context, arg);

    var analyzedResults = bodyAnalyzedResults(context, env, o.ast.definition);

    saveAnalyzedResults(s, returns, analyzedResults);

    return complete?;
}
overload analyzeCallableDeclaredReturns(s, env, o, namedReturns:Vector[ast.NamedReturn]) {
    try {
        var complete? = true;
        var returns = SpecializationReturns();
        var context = SpecializationContext(&just(s.body), &complete?, &returns);
        for (arg in s.internalArgs)
            addRvalue(context, arg);

        // must return void since returns are already named
        returns.results? = true;

        var analyzedResults = bodyAnalyzedResults(context, env, o.ast.definition);

        s.results = maybe(analyzedResults,
            x ref=> Maybe(computeNamedReturnSpec(namedReturns, env)),
            () ref=> nothing(RTValues),
        );

        return complete?;
    } catch (ex:RecursiveAnalysisError) {
        s.body = nothing(Vector[ir.Node]);
        s.results = Maybe(computeNamedReturnSpec(namedReturns, env));
        return false;
    }
}
overload analyzeCallableDeclaredReturns(s, env, o, declaredReturns:Vector[ast.ReturnSpec]) {
    try {
        if (variantIs?(o.ast.definition.body, ast.LiteralCodeBody))
            genericError("literal procedure must use named return values");

        var complete? = true;
        var returns = SpecializationReturns();
        var context = SpecializationContext(&just(s.body), &complete?, &returns);
        for (arg in s.internalArgs)
            addRvalue(context, arg);

        returns.results? = true;
        returns.results = computeReturnSpec(declaredReturns, env);
        returns.namedResults = map(asNamedReturnVariable, returns.results);

        var analyzedResults = bodyAnalyzedResults(context, env, o.ast.definition);

        saveAnalyzedResults(s, returns, analyzedResults);

        return complete?;
    } catch (ex:RecursiveAnalysisError) {
        s.body = nothing(Vector[ir.Node]);
        s.results = Maybe(computeReturnSpec(declaredReturns, env));
        return false;
    }
}

private analyzeCallableReturns(s:Specialization, env, o:Overload) {
    s.body = Maybe(Vector[ir.Node]());
    try {
        return withLocation(o.ast.definition, () ref=> {
            var complete? = analyzeCallableDeclaredReturns(s, env, o,
                *o.ast.definition.returns
            );
            if (not complete?)
                s.body = nothing(Vector[ir.Node]);
            return complete?;
        });
    } catch (ex) {
        s.body = nothing(Vector[ir.Node]);
        throw ex;
    }
}

overload analyzeCallableReturns(s) = analyzeCallableReturns(s, s.env, s.matchedOverload);

analyzeCallableBody(s)
    = withCallAnalysis(s.callable, s.args, () ref=> analyzeCallableReturns(s));

private entrySpecialization(entry:InvokeEntry) {
    return maybe(entry.specialization,
        x => x,
        () => {
            recursiveAnalysisError();
            return Specialization();
        },
    );
}

private callableInvokeTable(callable:Value) {
    return ref match(callable,
        Symbol, x => ref x.invokeTable,
        SymbolHead, x => ref x.invokeTable,
        RuntimeLambdaValue, x => ref x.invokeTable,
        Primitive, x => {
            matchFailureError("static primitive called in runtime context: ", x);
            return ref typeToLValue(InvokeTable);
        },
        RTPrimitive, x => {
            assert(false, "runtime primitive should be handled before consulting invoke table");
            return ref typeToLValue(InvokeTable);
        },
        MatchDefault, x => {
            genericError("invalid runtime callable: ", x);
            return ref typeToLValue(InvokeTable);
        },
    );
}


//
// analyzeCallable
//

analyzeCallable(callable:Value, args:RTValues) Specialization
    = withCallAnalysis(callable, args, () ref=> analyzeCallable2(callable, args));

analyzeCallable2(callable:Value, args:RTValues) Specialization {
    ref invokeTable = callableInvokeTable(callable);
    var entryPtr = lookup(invokeTable, ArgumentList(args));
    if (not null?(entryPtr))
        return entrySpecialization(entryPtr^);
    var lowered? = false;
    var loweredArgs = Vector[RTValue]();
    invokeTable[ArgumentList(args)] = InvokeEntry(nothing(Specialization));
    try {
        var specialization = findOverload(getProgram(), callable, args);
        loweredArgs = specialization.args;
        if (not equalArguments?(loweredArgs, args)) {
            var entryPtr = lookup(invokeTable, ArgumentList(loweredArgs));
            if (not null?(entryPtr)) {
                var s = entrySpecialization(entryPtr^);
                invokeTable[ArgumentList(args)].specialization = Maybe(s);
                return s;
            }
            invokeTable[ArgumentList(loweredArgs)] = InvokeEntry(nothing(Specialization));
            lowered? = true;
        }
        alias s = specialization;
        analyzeCallableReturns(s);
        invokeTable[ArgumentList(args)].specialization = Maybe(specialization);
        if (lowered?)
            invokeTable[ArgumentList(loweredArgs)].specialization = Maybe(specialization);
        return specialization;
    }
    catch (e) {
        remove(invokeTable, ArgumentList(args));
        if (lowered?) {
            remove(invokeTable, ArgumentList(loweredArgs));
        }
        throw e;
    }
}


//
// analyzeGlobalConstructor
//

analyzeGlobalConstructor() Maybe[Specialization] {
    ref globalMap = getProgram().globalMap;
    var specialization = Specialization(
        Value(StringValue(String("global constructor")))
    );
    specialization.env = newEnv(getProgramMainModule());
    specialization.body = Maybe(Vector[ir.Node]());
    ref body = just(specialization.body);
    for (g in reversed(globalMap.globalOrder)) {
        assert(not null?(lookup(globalMap.constructors, g)), "missing constructor in global map!");
        push(body, globalMap.constructors[g]);
    }

    if (empty?(body))
        return nothing(Specialization);
    else
        return Maybe(specialization);
}


//
// analyzeLambda
//

analyzeLambda(s:SpecializationContext, env:Env, expr:ast.LambdaExpr) {
    var lambda = RuntimeLambdaValue(expr, env);
    var staticValue = singleAddSpecializedStaticValue(s, expr, Value(lambda));
    if (statelessRuntimeLambda?(lambda))
        return Maybe(RTValues(staticValue));

    var captures = RTValues(staticValue);

    for (capturedName in lambda.value.capturedOrder) {
        var capturedValues = analyzeEnvEntry(
            s, lambda.value, privateLookup(lambda.env, capturedName)
        );
        if (nothing?(capturedValues))
            return nothing(RTValues);
        push(captures, just(capturedValues));
    }
    return analyzeCallWithOneResult(s, expr, getHooks().captureLambda, captures);
}
